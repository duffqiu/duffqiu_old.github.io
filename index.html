
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Duff Qiu's Blog</title>
  <meta name="author" content="Duff Qiu">


<meta name="msvalidate.01" content="359198A91024370BBF46839C4C26D15C" />


<link href='/assets/global-b1b395211846173799f0711df4f54741.css' rel='stylesheet' type='text/css' />


<script src='/assets/global-5e34cf1ef175a3de4d7313a57002bfda.js' type='text/javascript'></script>


  
  <meta name="description" content="原由 通常我们设计程序的时候都会分为3个层面，MVC是最通用的分层方式。一个是展示层，一个逻辑处理层，一个存储层。但是对于逻辑处理层还可以抽象分为两个层次，一个固定逻辑层，一个动态逻辑层。
对于动态逻辑层的实现，在Java中一般可以使用JavaScript引擎来执行JavaScript脚本。 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://duffqiu.github.io">
  <link href="/favicon.png" rel="icon">
<!--
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css"> -->
  <link href="/atom.xml" rel="alternate" title="Duff Qiu's Blog" type="application/atom+xml">
  <!-- <script src="/javascripts/modernizr-2.0.js"></script> -->
  <!-- <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script> -->
  <!-- <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script> -->
  <!-- <script src="/javascripts/octopress.js" type="text/javascript"></script> -->
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href='/assets/global-f6f2ffe885aa2c8ef058614d20be188a.css' rel='stylesheet' type='text/css' />


<script src='/assets/global-5e34cf1ef175a3de4d7313a57002bfda.js' type='text/javascript'></script>


<!-- <link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css"> -->
<!-- <link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css"> -->

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-47478128-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Duff Qiu's Blog</a></h1>
  
    <h2>Duff Qiu的个人博客，只为记录一个过程，结果都是浮云☁️！</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:duffqiu.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">首页</a></li>
  <li><a href="/blog/categories/java/">Java编程</a><li>
  <li><a href="/blog/categories/scala/">Scala编程</a><li>
  <li><a href="/blog/categories/uml/">UML Tips</a><li>
  <li><a href="/blog/categories/osx/">OSX经验与Tips</a><li>
  <li><a href="/blog/categories/octopress/">Octopress经验</a><li>
  <li><a href="/blog/archives">全部文章</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/03/03/scala-script/">Scala作为脚本语言动态执行</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-03-03T17:05:37+08:00" pubdate data-updated="true">Mar 3<span>rd</span>, 2015</time>
        
        
           | <a href="/blog/2015/03/03/scala-script/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3 id="section">原由</h3>
<hr />
<p>通常我们设计程序的时候都会分为3个层面，MVC是最通用的分层方式。一个是展示层，一个逻辑处理层，一个存储层。但是对于逻辑处理层还可以抽象分为两个层次，一个固定逻辑层，一个动态逻辑层。
对于动态逻辑层的实现，在Java中一般可以使用JavaScript引擎来执行JavaScript脚本。在Scala的程序中也可以这样做。不过Scala增加了使用Scala语言本身作为scritp语言。即Scala代替Javascript。
在2.11的REPL中可以这样做了，参见<a href="/blog/2015/03/02/scala211-overview/">Scala2.11Overview</a>
那么在代码中如何做呢？找了半天都没有找到官方的例子，尝试的过程中不是发现Null Point Exception的此错误就是说xxx Not Found (xxx是指Scala的类型，如Object, Int等)
在Junjun的提醒下，可能是ClassLoader的问题，造成script的执行找不到对应的jar包（包括Scala的标准包），因为默认情况下，ScriptEngine是在bootstrap路径下找jar包。参见<a href="http://docs.oracle.com/javase/7/docs/technotes/tools/findingclasses.html">Java如何找CLASS文件</a></p>

<h3 id="section-1">解决办法</h3>
<hr />

<ul>
  <li>先来看看原来在REPL中调用ScalaScript(尽管Script的代码依然是Scala，为了好区分这些是动态执行的Scala,暂且叫他ScalaScript)</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">import javax.script.ScriptEngineManager
</span><span class="line">val e = new ScriptEngineManager().getEngineByName("scala")
</span><span class="line">e.put("n", 10)
</span><span class="line">e.eval("1 to n.asInstanceOf[Int] foreach println")</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>
    <p>这些代码如果直接搬到Scala程序中，然后通过<code>java -jar</code>的方式运行是回出现我前面提到的错误的</p>
  </li>
  <li>
    <p>解决方式1： 使用<code>-xXbootclasspath</code>来指定scalascript中用到的jar包，包含scala的标准包，因为bootstrao只包含了JAVA的rt.jar以及jre/lib下面的jar包。</p>
  </li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">java -Xbootclasspath/a:/usr/scala-2.11.4/lib/scala-library.jar:/usr/scala-2.11.4/lib/scala-compiler.jar:/usr/scala-2.11.4/lib/scala-reflect.jar -jar  &lt;your jar file&gt;
</span><span class="line">//注意/a:/是固定的格式，具体可以查Jdk的文档</span></code></pre></td></tr></table></div></figure></notextile></div>
<pre><code>- 但是这个方式在前面的&lt;&lt;Java如何找CLASS文件&gt;&gt;的文中不建议，同时使用起来也比较麻烦
</code></pre>

<ul>
  <li>解决方式2： 在代码中指定scalascript和调用程度本身使用相同的jar包，代码如下：</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class=""><span class="line">import javax.script.ScriptEngineManager
</span><span class="line">import javax.script.ScriptEngine
</span><span class="line">
</span><span class="line">val m = new ScriptEngineManager()
</span><span class="line">val engine = m.getEngineByName("scala")
</span><span class="line">
</span><span class="line">//需要设计的属性
</span><span class="line">val settings = engine.asInstanceOf[scala.tools.nsc.interpreter.IMain].settings
</span><span class="line">settings.usejavacp.value = true  //使用程序的class path作为engine的class path
</span><span class="line">
</span><span class="line">engine.put("m", 10)
</span><span class="line">engine.eval("1 to m.asInstanceOf[Int] foreach println")</span></code></pre></td></tr></table></div></figure></notextile></div>
<pre><code>- 在sbt的工程中，将scala的标准包都变成依赖包，显示指定
- 然后通过`sbt assembly`来打包程序为胖程序（即包含所有的依赖包），`sbt package`不会包含依赖包的
- 直接通过`jar -jar &lt;your jar file&gt;`就可以了.
</code></pre>

<h4 id="section-2">官方讨论</h4>

<p><a href="https://github.com/scala/scala/pull/2238">Scala Issue 2238</a></p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/03/02/scala211-overview/">Scala211特性简介</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-03-02T12:02:16+08:00" pubdate data-updated="true">Mar 2<span>nd</span>, 2015</time>
        
        
           | <a href="/blog/2015/03/02/scala211-overview/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3 id="section">原由</h3>
<hr />
<p>Scala语言本生的变更还是比较快的，现在最通用是2.10和2.11版本
那么是否需要用2.11版本呢？
我们来看一看2.11的一些特性。参考于<a href="http://docs.scala-lang.org/scala/2.11/">scala2.11overview</a></p>

<h3 id="scala-211">Scala 2.11特性简介</h3>
<hr />

<ul>
  <li>
    <p>更小</p>

    <ul>
      <li>Actor包被废弃，如果的需要直接用Akka的包，已经被包含在了Scala的版准语言包了</li>
      <li>XML包被移除出scala-library.jar，编程了一个独立的包，如需要可以加入如下依赖 <code>libraryDependencies += "org.scala-lang.modules" %% "scala-xml" % "1.0.3"</code></li>
    </ul>
  </li>
  <li>更快: 提高了性能</li>
  <li>
    <p>更强</p>

    <ul>
      <li>语言：支持case class的参数多于22个参数(参见：<a href="https://issues.scala-lang.org/browse/SI-7296">1</a>)</li>
      <li>语言：增强类型推断。(不过好像这个问题又被打开了, 参见<a href="https://issues.scala-lang.org/browse/SI-1786">2</a>)</li>
      <li>REPL: 这个增强了很多项， 不一一举例了，下面是一些我个人觉得有用的。</li>
    </ul>
  </li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">scala&gt; :settings &lt;+/-&gt; &lt;flag&gt;
</span><span class="line">//这个主要是针对在REPL中提示有warning的时候，需要使用某些启动参数。原来的方式是需要退出REPL然后再用指定参数启动。现在可以直接通过这个名利来激活(+)/去除(-)某个特性(flag)，如显示deprecation，则用":settings + deprecation"</span></code></pre></td></tr></table></div></figure></notextile></div>

<pre><code>- REPL: 支持script引擎 (我个人没有用过scala下的script引擎，不知道。后面再写个如何在[代码中动态执行Scala](/blog/2015/03/03/scala-script/))
</code></pre>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/02/26/ssh-proxy-in-linux/">Ssh在linux下使用http/https代理</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-02-26T18:00:30+08:00" pubdate data-updated="true">Feb 26<span>th</span>, 2015</time>
        
        
           | <a href="/blog/2015/02/26/ssh-proxy-in-linux/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3 id="section">原由</h3>
<hr />
<p>在公司有代理的环境下，如果在linux下使用github，则可以使用https的方式。
但是https的方式需要每次都输入用户名和密码（用户名可以写在url上避免输入，但是密码就必须要）
但是如果能使用ssh的rsa方式则可以避免这个麻烦，但是ssh默认是不支持使用http/https代理的。
那么有没有办法通过某种手段让ssh支持代理呢？答案是可定的，这个工具是<a href="http://www.agroman.net/corkscrew/">Corkscrew官网</a></p>

<h3 id="section-1">解决办法</h3>
<hr />

<p>通过Corkscrew来建立隧道的方式来为ssh提供代理，具体方法如下 </p>

<ul>
  <li>安装Corkscrew（主要下载源代码，然后配置、编译、安装，典型的C程序的方式）</li>
  <li>配置ssh，在~/.ssh/目录下生成一个config=文将，然后增加一行：<code>ProxyCommand /usr/local/bin/corkscrew &lt;proxy http url&gt; &lt;proxy port&gt; %h %p</code></li>
  <li>如果是新建的config文件，注意要更改一下它的权限为600，<code>chmod 600 ~/.ssh/config</code></li>
  <li>根据github的说明配置ssh的public和private key,参考<a href="https://help.github.com/articles/generating-ssh-keys/#platform-linux">git帮助</a></li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/02/25/sublime-startup/">Sublime入门以及搭建scala开发环境</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-02-25T14:49:46+08:00" pubdate data-updated="true">Feb 25<span>th</span>, 2015</time>
        
        
           | <a href="/blog/2015/02/25/sublime-startup/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3 id="section">原由</h3>
<hr />
<p>Sublime号称是神级编辑器，同时支持多种插件的扩展。并且支持多个平台。
这里主要讲以下如何安装和配置，并说明一下如何使用scala插件来搭建开发环境，
避免使用其他的IDE这么重的工具，节约内存和系统消耗</p>

<h3 id="sublime">sublime使用入门</h3>
<hr />

<ul>
  <li>
    <p>安装sublime
可以直接从<a href="http://www.sublimetext.com/">sublime官网</a>下载对应的版本安装
这里针对不同的系统的配置的文件的路径如下：</p>

    <ul>
      <li>Mac OSX: <code>~/Library/Library/Application Support/Sublime Text 3</code></li>
      <li>Linux CentOS7: <code>~/.config/sublime-text-3</code></li>
    </ul>
  </li>
</ul>

<p>Mac OSX有对应的dmg安装包，一部一部安装就可以
CentOS7没有安装包，需要下载压缩包，4然后解压到<code>/opt/sublime-text</code>目录(注意要把名字中的3去掉)，然后将目录中的sublime_text.desktop复制到<code>/usr/share/applications</code>，这样在CentOS的启动菜单上就对应的图表了</p>

<ul>
  <li>
    <p>安装包管理插件Package Control</p>

    <ul>
      <li>最先要安装的是插件<a href="https://packagecontrol.io/installation">管理工具Package Control</a>: 下载插件包，然后放到配置路径的Installed Packages目录下就可以了。</li>
      <li>每次通过<code>shift+Ctrl+P</code>来打开命令板选择“Package Control: Install Package”来安装插件</li>
    </ul>
  </li>
  <li>
    <p>安装scala插件SublimeREPL</p>

    <ul>
      <li><code>shift+Ctrl+P</code>来打开命令板选择“Package Control: Install Package”，然后选择SublimeREPL</li>
      <li>安装成功后就可以在命令板中选择对应的scala/sbt来打开scala REPL和sbt REPL了</li>
      <li>配置： 有可能你安装sbt/scala的目录不同，造成无法打开scala REPL和sbt REPL，这个时候需要手工配置一下。在配置的文件的路径下找到<code>Packages/SublimeREPL/config/Scala</code>目录下的Main.sublime-menu文件，编辑该文件，为对应的scala和sbt指定好对应的目录就可以了</li>
      <li>使用：对于SublimeREPL:scala只是打开了scala REPL，用处不大，可以使用下面的scala worksheet插件代替。但是对于SublimeREPL:sbt则比较有用。方式是通过sublime先打开sbt的工程的目录，然后在命令板执行SublimeREPL:SBT for opened folder。不过还有更方便的插件SbblimeSBT</li>
    </ul>
  </li>
  <li>
    <p>安装scala worksheet插件</p>

    <ul>
      <li><code>shift+Ctrl+P</code>来打开命令板选择“Package Control: Install Package”，然后选择Scala Worksheet</li>
      <li>安装成功后就可以在命令板中选择对应的show scala worksheet了。</li>
      <li>使用方式是编写对应的scala文件并保存后，再执行show scala worksheet，这样scala REPL就自动会执行你编辑的文件了。</li>
      <li>有可能在打开show scala worksheet出现无法找到scala的无法，简单的解决方式是在1<code>/usr/bin</code>下给scala建立一个soft link <code>sudo ln &lt;scala install path&gt; /usr/bin/scala</code></li>
      <li>如果需要给Scala worksheet增加额外的jar包，则需要配置Sublime中的setting。<code>preferences-&gt;Settings - User</code>，然后增加一个JSON key: (注意不要用相对路径，要用绝对路径)</li>
    </ul>
  </li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">"scala_worksheet_classpath":
</span><span class="line">[
</span><span class="line">	"&lt;jar path&gt;/&lt;jar name&gt;"
</span><span class="line">]</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>
    <p>安装SublimeSBT插件</p>

    <ul>
      <li><code>shift+Ctrl+P</code>来打开命令板选择“Package Control: Install Package”，然后选择SublimeSBT</li>
      <li>使用：shift+Ctrl+P`来打开命令板选择SBT: xxx来运行对应的sbt命令</li>
    </ul>
  </li>
  <li>
    <p>给对应的scala sbt项目配置SBT插件：sbt-sublime </p>

    <ul>
      <li>在project/plugin.sbt中增加<code>addSbtPlugin("com.orrsella" % "sbt-sublime" % "1.0.9")</code></li>
      <li>在sbt console中调用<code>gen-sublime</code>来获取依赖包的源文件以及生成sublime的工程文件（每次SBT Clean都会自动删除这些文件。）。这样也节约了需要在每一个依赖包的定义后面增加withSource的选项</li>
      <li>使用步骤1： 在sublime中， project-&gt;open project来打开生成sublime的工程文件，这个时候将会将SBT的工程目录加载进来，同时多了一个External Libraries的目录（其存放了依赖包的源代码）</li>
      <li>使用步骤2： 使用SublimeSBT插件调用SBT: Start continus compiling，这样每次更改源文件都会被自动编译。如果发现错误，则Sublime会自动提示在那一行代码上</li>
      <li>使用步骤3： 因为引入了依赖包的源代码，则可以通过在sublime中的Goto菜单来调转到指定的类/方法的源文件处(仅Sublime Text 3支持)</li>
      <li>使用步骤4： 使用Snippet：case class…等来协助快速编写代码（但是不知道是上面哪个插件体提供的了）</li>
    </ul>
  </li>
  <li>
    <p>使用Git插件，在“Package Control: Install Package”中选择Git就可以了，然后在命令板选择对应的Git:xxx命令就可如Git status。</p>
  </li>
</ul>

<p>Sublime搭建Scala开发环境小结：
    - 总体而言还是不错，运行速度又快，基本的功能都有
    - 但是唯一的遗憾是没有办法在编写代码的时候自动提示可能的方法/类等</p>

<h4 id="section-1">小提示</h4>
<p>对于sublime text 3的最新版本在linus下无法使用ibus的输入法，所以编写这个blog的时候我又回到了gedit
从这个对比来看，linus和mac osx从个人用户的使用来看还是差很远的</p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/02/23/mac-port-guide/">Mac下port工具的使用</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-02-23T22:29:35+08:00" pubdate data-updated="true">Feb 23<span>rd</span>, 2015</time>
        
        
           | <a href="/blog/2015/02/23/mac-port-guide/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3 id="section">原由</h3>
<hr />

<p>Mac下面除了用dmg、pkg来安装软件外，比较方便的还有用MacPorts来帮助你安装其他应用程序，跟BSD中的ports道理一样。MacPorts就像apt-get、yum一样，可以快速安装些软件。</p>

<p>Mac下还有brew可以用来管理软件包，但是个人不喜欢这个工具，还是比较倾向于用port</p>

<h3 id="section-1">工具使用详解</h3>
<hr />

<ul>
  <li>更新ports tree(即软件信息列表)和MacPorts版本，强烈推荐第一次运行的时候使用-v参数，显示详细的更新过程。</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sudo port -v selfupdate</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>搜索索引中的软件</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">port search &lt;name&gt;</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>安装新软件</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sudo port install &lt;name&gt;</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>卸载软件</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sudo port uninstall &lt;name&gt;</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>递归卸载要卸载的软件所依赖的软件包，但这一命令不会卸载那些又依赖其他软件包的软件。</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sudo port uninstall --follow-dependencies software_name </span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>查看有更新的软件以及版本</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">port outdated</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>升级可以更新的软件</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sudo port upgrade outdated </span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>升级软件并且同时升级所依赖的软件包</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sudo port upgrade &lt;name&gt; </span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>关闭软件</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sudo port deactivate &lt;name&gt;</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>查询所需软件信息</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sudo port info &lt;name&gt; </span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>查看软件依赖性：</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sudo port deps &lt;name&gt;  </span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>清理安装过程中的缓存文件，在获取软件失败时也可以使用：</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sudo port clean --all &lt;name&gt;  </span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>查看已经安装的软件的内容信息</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">port contents &lt;name&gt;  </span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>查看已安装软件的信息</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sudo port installed &lt;name&gt;  </span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>报告所查询软件的依赖包情况</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">port dependents &lt;name&gt;  </span></code></pre></td></tr></table></div></figure></notextile></div>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/02/23/integrate-sbt-project-jenkins/">集成SBT到Jenkins中</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-02-23T14:56:24+08:00" pubdate data-updated="true">Feb 23<span>rd</span>, 2015</time>
        
        
           | <a href="/blog/2015/02/23/integrate-sbt-project-jenkins/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3 id="section">原由</h3>
<hr />

<p>之前有些过关于Jenkins上搭建maven工程<a href="/blog/2014/02/06/yong-jenkinsda-jian-ji-yu-githubhe-junitde-zi-dong-hua-ce-shi/">1</a>，但是对于Scala的工程最好还是用SBT，那么如何在Jenkins用SBT呢？</p>

<h3 id="section-1">解决办法</h3>
<hr />

<p>Jenkins已经提供了SBT的插件，类似Maven的插件</p>

<p>具体步骤如下：</p>

<ul>
  <li>在Jenkins上的系统管理-&gt;管理Jenkins-&gt;管理插件中选择可选插件，然后输入sbt过滤条件</li>
  <li>选择安装sbt plugin</li>
  <li>重启Jenkins</li>
  <li>配置sbt：系统管理-&gt;系统设置，设置”sbt lauch jars”，注意这里是指具体的jar文件，不是配置路径。如<code>/opt/local/share/sbt/sbt-launch.jar</code>  </li>
  <li>新建项目（因为不像Maven有特定的选项），所以选择”构建一个自由风格的软件项目”  </li>
  <li>然后在构建步骤中选择”Build using SBT”，然后配置对应的参数。这里需要注意的是JVM Flags，如果不配置很可能PerGem不够造成OutofMemoryError。但是该配置什么呢？如果不是太清楚，则可以直接拷贝sbt的启动脚本中的JVM Flags参数，如我机器的：<code>-XX:+CMSClassUnloadingEnabled -Xms1536m -Xmx1536m -XX:MaxPermSize=384m -XX:ReservedCodeCacheSize=192m -Dfile.encoding=UTF8</code></li>
  <li>如果Git repo下是涵盖了多个项目，则可以制定sub-directory path来运行特定个项目</li>
</ul>

<h3 id="section-2">小插曲</h3>

<h4 id="linuxunix">Linux/Unix下跟踪或查看文件的命令</h4>

<ol>
  <li>输入文件到console: <code>cat &lt;filename&gt;</code></li>
  <li>逐行显示文件: <code>less &lt;filename&gt;</code></li>
  <li>显示文件最后的一屏: <code>tail &lt;filename&gt;</code></li>
  <li>如果需要跟踪文件的变化则: <code>tail -f &lt;filename&gt;</code></li>
</ol>

<h4 id="git">Git清理工作空间</h4>

<p>如果在某个Repo中，你不小心加入了很多没用的文件和文件目录（或者是因为没有checkout到真确的branch就做了pull操作），则你期望一次性清理掉这些文件，可以用以下命令
不过需要注意的是这个操作不可逆的，可以通过增加<code>-n</code>参数来预览一下将会有什么变化</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="sh"><span class="line">git clean -fdx
</span></code></pre></td></tr></table></div></figure></notextile></div>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/02/10/sbt-for-new-user/">初学sbt</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-02-10T15:22:32+08:00" pubdate data-updated="true">Feb 10<span>th</span>, 2015</time>
        
        
           | <a href="/blog/2015/02/10/sbt-for-new-user/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3 id="section">原由</h3>
<hr />
<p>初学一种语言最烦的就是搭建开发环境了，每次都要装一堆的plugin，有时候又因为不同的plugin的版本等问题冲突
前面介绍如何使用Maven来搭建开发环境，总体而言还算比较复杂。特别是在不同的机器上竟然有些plugin不可用，也不知道问题在那里。
所以既然是以开发Scala为主，那还是用<a href="http://scala-sbt.org">SBT</a>吧</p>

<h3 id="section-1">主要参考</h3>
<hr />
<p>直接参考<a href="http://www.scala-sbt.org/0.13/tutorial/index.html">SBT官网的Getting Started</a>并结合自己的一些实践做了下浓缩
官网已经提供中文版本了(开来中国是用Scala增长比较快的地区，另一个是美国硅谷，有兴趣可以看看google trend上关于Scala)</p>

<p>该Getting Started有几章可以暂时不用看的，到真的有需要再看
- Scope
- Multi-project builds
- Custom settings and tasks
- .scala build definition</p>

<p>另外在Github上有个<a href="https://github.com/n8han/giter8">giter8，简称g8</a>的工具，可以帮助获取scala, sbt的模版，不过自从有了<a href="http://typesafe.com/get-started">typesafe的activator</a>后，提供g8模版已经不多了，原有的模版也没怎么更新了</p>

<h4 id="sbt">安装SBT</h4>
<p>可以根据SBT官网的Getting Started，对于不同的平台采用不同的安装方式
安装完后，基本上就是一个sbt的命令脚本和sbt-launch.jar
安装完后，通过命令行运行一次<code>sbt</code>，然后sbt会将对应的依赖包下载下来。
sbt会在用户的home目录下创建.sbt和.ivy2的目录，依赖包都放在了ivy2的目录里。因为sbt实际是通过ivy2来管理包依赖。不过大家不用去看ivy2，这些都是sbt自己管理的。
如果是公司有代理的环境中，则需要设置java代理的参数才可以使用，不然sbt总是在尝试下载依赖包。
一般设置java代理的参数是在shell的文件中设置JAVA_OPTS,但是好像不其作用。所以最好的方式是直接修改sbt的命令脚本增加代理配置参数</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="sh"><span class="line"><span class="nv">JAVA_OPTS</span><span class="o">=</span><span class="s2">&quot;$JAVA_OPTS -Dhttp.proxyHost=&lt;proxy host&gt; -Dhttp.proxyPort=&lt;proxy port&gt; -Dhttps.proxyHost=&lt;proxy host&gt; -Dhttps.proxyPort=&lt;proxy port&gt;&quot;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="scalajava">建立一个scala/java工程</h4>
<p>建议不要从参考SBT官网的Getting Started的hello world，因为它将源文件建在了工程的根目录上了
很奇怪，到目前位置都没有个一个像maven那样可以直接在Eclipse上创建一个sbt的工程，而必须先手工创建一些文件</p>

<p>具体步骤为：</p>

<ul>
  <li>创建一个工程目录如： sbt-sample</li>
  <li>在工程目录下再创建一个子目录，必须名为project</li>
  <li>在工程目录下创建名为build.sbt的定义文件，并写入基本的信息，需要注意的是每个配置都要空一行。以后打开别人的工程先看看这个文件的基本定义，特比是scala的版本</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="sh"><span class="line">name :<span class="o">=</span> <span class="s2">&quot;sbt-sample&quot;</span>
</span><span class="line">
</span><span class="line">version :<span class="o">=</span> <span class="s2">&quot;1.0&quot;</span>
</span><span class="line">
</span><span class="line">scalaVersion :<span class="o">=</span> <span class="s2">&quot;2.11.4&quot;</span>
</span><span class="line">
</span><span class="line">organization :<span class="o">=</span> <span class="s2">&quot;org.duff&quot;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<ul>
  <li>使用<a href="https://github.com/typesafehub/sbteclipse">sbteclpise</a>插件， 在project子目录下创建一个plugins.sbt文件，然后加入一下内容，然后在sbt的命令行下执行<code>eclipse</code>就可以生成对应的eclipse的工程了。如果改动了sbt的文件则最后重新执行一次<code>eclipse</code>获得最新的包依赖等</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="sh"><span class="line">addSbtPlugin<span class="o">(</span><span class="s2">&quot;com.typesafe.sbteclipse&quot;</span> % <span class="s2">&quot;sbteclipse-plugin&quot;</span> % <span class="s2">&quot;2.5.0&quot;</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>打开Eclipse，写个测试的App</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="kn">package</span> <span class="n">org</span><span class="o">.</span><span class="na">duff</span><span class="o">.</span><span class="na">sbtsample</span>
</span><span class="line">
</span><span class="line"><span class="n">object</span> <span class="n">Main</span> <span class="kd">extends</span> <span class="n">App</span><span class="o">{</span>
</span><span class="line">
</span><span class="line">  <span class="n">println</span><span class="o">(</span><span class="s">&quot;this is a sbt sample&quot;</span><span class="o">)</span>
</span><span class="line">
</span><span class="line"><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>
    <p>在sbt命令行下执行<code>compile</code>，然后<code>run</code>就可以看到对应的输入了</p>
  </li>
  <li>
    <p>设置包依赖仓库（repository）。对于Maven是设置的Maven的conf文件中，但是对于SBT是每次定义在项目的build.sbt文件中</p>

    <ul>
      <li>方法一： 通过URL定义如： <code>resolvers += "&lt;rep name&gt;" at "&lt;rep url&gt;"</code></li>
    </ul>
  </li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="sh"><span class="line">resolvers +<span class="o">=</span>
</span><span class="line">  <span class="s2">&quot;Sonatype OSS Snapshots&quot;</span> at <span class="s2">&quot;https://oss.sonatype.org/content/repositories/snapshots&quot;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>
    <p>方法二： 使用<a href="http://www.scala-sbt.org/0.13/docs/Resolvers.html">预定义的Rep</a>，主要有：</p>

    <ul>
      <li>DefaultMavenRepository at  https://repo1.maven.org/maven2/，这个会被默认使用，无需指定</li>
      <li>JavaNet1Repository  at http://download.java.net/maven/1/</li>
      <li>Resolver.sonatypeRepo(“public”) (or “snapshots”, “releases”) at https://oss.sonatype.org/content/repositories/public</li>
      <li>Resolver.typesafeRepo(“releases”) (or “snapshots”) at https://repo.typesafe.com/typesafe/releases</li>
      <li>Resolver.typesafeIvyRepo(“releases”) (or “snapshots”) at https://repo.typesafe.com/typesafe/ivy-releases</li>
      <li>Resolver.sbtPluginRepo(“releases”) (or “snapshots”) at https://repo.scala-sbt.org/scalasbt/sbt-plugin-releases</li>
      <li>Resolver.bintrayRepo(“owner”, “repo”) at https://dl.bintray.com/[owner]/[repo]/</li>
      <li>Resolver.jcenterRepo at https://jcenter.bintray.com/</li>
    </ul>
  </li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="sh"><span class="line">resolvers +<span class="o">=</span> JavaNet1Repository
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>方法三：同时指定多个rep，使用<code>resolvers ++= Seq(&lt;rep1&gt;, &lt;rep2&gt;)</code>, rep1/rep2可以使用方法一或方法二</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="sh"><span class="line">resolvers ++<span class="o">=</span> Seq<span class="o">(</span>Resolver.sonatypeRepo<span class="o">(</span><span class="s2">&quot;public&quot;</span><span class="o">)</span>,
</span><span class="line">    Resolver.typesafeRepo<span class="o">(</span><span class="s2">&quot;releases&quot;</span><span class="o">))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>指定工程依赖包，和resolver类似，可以一个一个指定(+=)，也可以同时指定(++= Seq())，另外如果需要对多个包使用同一个变量指定如scala版本等，则可以使用如下例子的方式(即Scala的闭包)</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="sh"><span class="line">libraryDependencies ++<span class="o">=</span> <span class="o">{</span>
</span><span class="line">  val <span class="nv">akkaVersion</span>       <span class="o">=</span> <span class="s2">&quot;2.3.9&quot;</span>
</span><span class="line">  val <span class="nv">sprayVersion</span>      <span class="o">=</span> <span class="s2">&quot;1.3.2&quot;</span>
</span><span class="line">  Seq<span class="o">(</span>
</span><span class="line">    <span class="s2">&quot;com.typesafe.akka&quot;</span> %% <span class="s2">&quot;akka-slf4j&quot;</span>      % akkaVersion withSources<span class="o">()</span> withJavadoc<span class="o">()</span>,
</span><span class="line">    <span class="s2">&quot;ch.qos.logback&quot;</span>    %  <span class="s2">&quot;logback-classic&quot;</span> % <span class="s2">&quot;1.1.2&quot;</span>,
</span><span class="line">    <span class="s2">&quot;com.typesafe.akka&quot;</span> %% <span class="s2">&quot;akka-testkit&quot;</span>    % akkaVersion   % <span class="s2">&quot;test&quot;</span>,
</span><span class="line">    <span class="s2">&quot;org.scalatest&quot;</span>     %% <span class="s2">&quot;scalatest&quot;</span>       % <span class="s2">&quot;2.2.0&quot;</span>       % <span class="s2">&quot;test&quot;</span> withSources<span class="o">()</span> withJavadoc<span class="o">()</span>
</span><span class="line">  <span class="o">)</span>
</span><span class="line"><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<ul>
  <li>每个lib的定义格式为 <code>&lt;groupID&gt; % &lt;artifactID&gt; % &lt;revision&gt; % configuration</code>。如上面的 ch.qos.logback，默认情况下都是”compile”的配置，而对于scalatest是指定在”test”的时候才使用</li>
  <li>如果artifactID是根据scala的版本有不同的版本则可以简化的使用%%的方式省去指定xxx_2.11.4 (使用scala 2.11.4)而是直接写xxx</li>
  <li>
    <p>需要同时下载javadoc和source，则可以在最后用withSources() withJavadoc()</p>
  </li>
  <li>
    <p>更改完后，如果还在sbt命令行下，则可以运行<code>reload</code>来更新相应的配置</p>
  </li>
  <li>
    <p>打包程序，如果使用的不同的framework/toolkit，则有不同的打包方式，一般的打包方式是打成大的jar包</p>

    <ul>
      <li>配置打包plugin，在project子目录中增加一个名为assembly.sbt的文件，增加以下内容</li>
    </ul>
  </li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="sh"><span class="line">addSbtPlugin<span class="o">(</span><span class="s2">&quot;com.eed3si9n&quot;</span> % <span class="s2">&quot;sbt-assembly&quot;</span> % <span class="s2">&quot;0.12.0&quot;</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<ul>
  <li>然后就可以在sbt命令行下执行<code>assembly</code>，则可以打包出jar文件了。可以在子目录target/scala-2.11/下找到这个jar</li>
  <li>通过执行<code>java -jar &lt;xxx.jar&gt;</code>来执行程序</li>
  <li>
    <p>可以通过在build.sbt中增加以下配置更改打包jar</p>

    <ul>
      <li><code>ssemblyJarName in assembly := "&lt;xxxx.jar&gt;"</code> 更改打包的jar文件名</li>
      <li><code>mainClass in assembly := Some("&lt;com.example.Main&gt;")</code> 更改main函数的入库</li>
      <li>如果像用工程的版本号来合成打包文件，则可以这样写 <code>assemblyJarName in assembly := "&lt;name&gt;" + version.value +".jar"</code></li>
    </ul>
  </li>
</ul>

<p>到此一个就本的sbt的scala开发环境就建成了。
后续不同的项目的变化基本上就集中在增加新的依赖包，增加不同的plugin来执行不同的任务
个人使用看来，对比maven相对而言要简单一些。只是SBT使用场景基本只局限于java和scala，同时sbt的写法是scala语法</p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/02/05/fp-or-imperative-with-scala/">Scala中函数式编程还是命令式编程</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-02-05T11:44:46+08:00" pubdate data-updated="true">Feb 5<span>th</span>, 2015</time>
        
        
           | <a href="/blog/2015/02/05/fp-or-imperative-with-scala/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3 id="section">原由</h3>
<hr />
<p>Scala是即支持传统的命令式编程也支持函数式编程(FP)，我们既可以像java那样写代码，也可以像Lisp那样写。
但是那种好呢？</p>

<h3 id="section-1">解决办法</h3>
<hr />
<p>个人的理解是，主要取决于对问题的解决方式的思路。
如果已经习惯了命令式编程的思路，那就用命令式编程好了。
不过既然FP已经逐渐成为潮流，那换换思路也未尝不可。
从Scala语言本身看两者没有冲突</p>

<h3 id="section-2">一个例子来对比两种思路</h3>
<hr />

<p>例子：有一个Map的数组/列表，要将不同Map中相同key的value值相加，最后得到一个Map</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="n">Vector</span><span class="o">(</span><span class="n">Map</span><span class="o">(</span><span class="s">&quot;test&quot;</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="s">&quot;hello&quot;</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">,</span> <span class="s">&quot;wwww&quot;</span> <span class="o">-&gt;</span> <span class="mi">9</span><span class="o">),</span> <span class="n">Map</span><span class="o">(</span><span class="s">&quot;test&quot;</span> <span class="o">-&gt;</span> <span class="mi">3</span><span class="o">,</span> <span class="s">&quot;hello&quot;</span> <span class="o">-&gt;</span> <span class="mi">5</span><span class="o">,</span> <span class="s">&quot;http&quot;</span> <span class="o">-&gt;</span> <span class="mi">33</span><span class="o">))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>期望得到的结果</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="n">Map</span><span class="o">(</span><span class="n">test</span> <span class="o">-&gt;</span> <span class="mi">4</span><span class="o">,</span> <span class="n">hello</span> <span class="o">-&gt;</span> <span class="mi">7</span><span class="o">,</span> <span class="n">wwww</span> <span class="o">-&gt;</span> <span class="mi">9</span><span class="o">,</span> <span class="n">http</span> <span class="o">-&gt;</span> <span class="mi">33</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>命令式编程方式
思路：循环Vector中的每个Map，然后循环Map中的每个Key-Value，将相同的Key对应的Value加起来后存入到一个临时的Map，最后返回这个Map</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="n">def</span> <span class="nf">merge</span><span class="o">(</span><span class="nl">input:</span> <span class="n">Vector</span><span class="o">[</span><span class="n">Map</span><span class="o">[</span><span class="n">String</span><span class="o">,</span> <span class="n">Int</span><span class="o">]])</span> <span class="o">=</span> <span class="o">{</span>
</span><span class="line">
</span><span class="line">  <span class="n">var</span> <span class="n">mergeRes</span> <span class="o">=</span> <span class="n">input</span><span class="o">.</span><span class="na">head</span>
</span><span class="line">  <span class="n">val</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">input</span><span class="o">.</span><span class="na">tail</span>
</span><span class="line">
</span><span class="line">  <span class="k">for</span><span class="o">(</span><span class="n">itr</span> <span class="o">&lt;-</span> <span class="n">temp</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">  	<span class="k">for</span><span class="o">((</span><span class="n">word</span><span class="o">,</span> <span class="n">count</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="n">itr</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">  		<span class="n">mergeRes</span> <span class="o">=</span> <span class="n">mergeRes</span> <span class="o">+</span> <span class="o">(</span><span class="n">word</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">mergeRes</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">word</span><span class="o">).</span><span class="na">getOrElse</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="n">count</span><span class="o">))</span>
</span><span class="line">  	<span class="o">}</span>
</span><span class="line">  <span class="o">}</span>
</span><span class="line">
</span><span class="line">  <span class="n">mergeRes</span>
</span><span class="line"><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>函数式编程方式
思路：对于Vector作折叠操作(reduceLeft)，因为每此计算都要以上一次计算作为输入。而计算中需要做的操作由使用者控制。同时对于每个Map都需要操作每个key-value并返回新的key-value所以用到map函数</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="java"><span class="line">  <span class="n">def</span> <span class="nf">mergeFP</span><span class="o">(</span><span class="nl">input:</span> <span class="n">Vector</span><span class="o">[</span><span class="n">Map</span><span class="o">[</span><span class="n">String</span><span class="o">,</span> <span class="n">Int</span><span class="o">]])</span> <span class="o">=</span> <span class="o">{</span>
</span><span class="line">    <span class="n">input</span><span class="o">.</span><span class="na">reduceLeft</span> <span class="o">{</span>
</span><span class="line">      <span class="o">(</span><span class="n">el</span><span class="o">,</span> <span class="n">acc</span><span class="o">)</span> <span class="o">=&gt;</span>
</span><span class="line">        <span class="n">el</span><span class="o">.</span><span class="na">map</span> <span class="o">{</span>
</span><span class="line">          <span class="k">case</span> <span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="n">count</span><span class="o">)</span> <span class="o">=&gt;</span>
</span><span class="line">            <span class="n">acc</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">word</span><span class="o">).</span><span class="na">map</span><span class="o">(</span><span class="n">accCount</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">word</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">accCount</span> <span class="o">+</span> <span class="n">count</span><span class="o">))).</span><span class="na">getOrElse</span><span class="o">(</span><span class="n">word</span> <span class="o">-&gt;</span> <span class="n">count</span><span class="o">)</span>
</span><span class="line">        <span class="o">}</span> <span class="o">++</span> <span class="o">(</span><span class="n">acc</span> <span class="o">--</span> <span class="n">el</span><span class="o">.</span><span class="na">keys</span><span class="o">)</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line">  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>从两者的对比俩看，如果不是熟悉FP的思路的化，似乎FP的代码更难看些。这也是为什么有人认为FP不利于代码沟通的原因吧。
但是从FP的实现看，中间没有任何可变变量（其实Scala对于reduceLeft用了中间可变变量，只是对于函数的使用者不需要了）</p>

<p><strong>注</strong> 改FP的例子载自Akka in Action，但是它的是foldLeft不是reduceLeft</p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/02/02/integration-pattern-canonical-data-model/">系统集成模式：规范化数据流模式</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-02-02T18:18:16+08:00" pubdate data-updated="true">Feb 2<span>nd</span>, 2015</time>
        
        
           | <a href="/blog/2015/02/02/integration-pattern-canonical-data-model/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3 id="section">原由</h3>
<hr />
<p><a href="/blog/2015/02/02/integration-pattern-normalizer/">Normalizer模式</a>中，我们提到到如果多个系统一起集成将造成Endpoint成几何级数的增长。</p>

<h3 id="section-1">解决办法</h3>
<hr />

<p>使用Canonical Data Model(规范化数据模型)来解决这个问题
其特点如下：
- 每一个EndPoint一端和集成系统衔接，接收或发送特定系统的消息
- 每一个EndPoint的另外一段则是接收或发送Common的消息给另外的EndPoint</p>

<p>如图1：
<img src="/images/cdm-1.png" alt="图一" /></p>

<ul>
  <li>所有的在EndPoint间流动的消息都是基于Common的接口，这样当引入一个新的系统的时候这需要实现一个EndPoint就可以了。</li>
</ul>

<p>如图二：
<img src="/images/cdm-2.png" alt="图二" /></p>

<p>当我们需要考入如何实现Endpoint的时候，则可以考虑<a href="http://camel.apache.org/">Apache Camel Framework</a></p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/02/02/fix-centos-virtualbox/">安装附属包失败后修复virtualbox上的centos</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-02-02T16:45:25+08:00" pubdate data-updated="true">Feb 2<span>nd</span>, 2015</time>
        
        
           | <a href="/blog/2015/02/02/fix-centos-virtualbox/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3 id="section">原由</h3>
<hr />
<p>在virtualbox安装好centos7后，共享windows下的目录以及在host机器作拷贝张贴都不行，总是提示virtualbox的附属包没有安装，所以重新进行了安装。
但是重装时发现virtualboxguess module（vboxguest）没有安装成功，提示需要安装kernel-develp包，然后再重装这个附属包。
按照提示用<code>sudo yum install kernel-develop</code>, 然后再重装这个附属包
重新启动后竟然网卡无法使用了，同时也无法mount cdrom来卸载这个virtualbox的附属包。</p>

<p>网卡提示的错误信息是：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
</pre></td><td class="code"><pre><code class=""><span class="line">11月 05 15:30:10 localhost.localdomain network[2920]: RTNETLINK answers: File exists
</span><span class="line">
</span><span class="line">11月 05 15:30:10 localhost.localdomain network[2920]: RTNETLINK answers: File exists
</span><span class="line">
</span><span class="line">11月 05 15:30:10 localhost.localdomain network[2920]: RTNETLINK answers: File exists
</span><span class="line">
</span><span class="line">11月 05 15:30:10 localhost.localdomain network[2920]: RTNETLINK answers: File exists
</span><span class="line">
</span><span class="line">11月 05 15:30:10 localhost.localdomain network[2920]: RTNETLINK answers: File exists
</span><span class="line">
</span><span class="line">11月 05 15:30:10 localhost.localdomain network[2920]: RTNETLINK answers: File exists
</span><span class="line">
</span><span class="line">11月 05 15:30:10 localhost.localdomain network[2920]: RTNETLINK answers: File exists
</span><span class="line">
</span><span class="line">11月 05 15:30:10 localhost.localdomain systemd[1]: network.service: control process exited, code=exited status=1
</span><span class="line">
</span><span class="line">11月 05 15:30:10 localhost.localdomain systemd[1]: Failed to start LSB: Bring up/down networking.
</span><span class="line">
</span><span class="line">11月 05 15:30:10 localhost.localdomain systemd[1]: Unit network.service entered failed state.</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Google了半天都没有办法，唯一能定位的地方是virtualbox修改了kernel的module造成</p>

<h3 id="section-1">解决办法</h3>
<hr />

<p>kernel的module一般都要通过原码的方式在本地编译后安装/加载，所以才需要kernel-develop的rpm包，难道问题在这里？
通过命令<code>rpm -qa|grep kernel</code>查看安装了的包，竟然发现有两个不同的版本的kernel-develop
那么可能的问题就出在了版本上
那就需要将不对的kernel-develop rpm包卸载掉并将对应的module删除后重新编印virtualbox的module
方法如下：</p>

<ul>
  <li>删除对应的编译需要的lib库： <code>sudo rm /lib/modules/3.10.0-123.el7.x86_64/misc/vbox*</code></li>
  <li>重建modules.dep和map文件: <code>sudo depmod -a</code></li>
  <li>重新加载module: <code>sudo modprobe module</code></li>
  <li>reboot</li>
  <li>这个时候应该cdroom和网卡都回来了</li>
  <li>重新安装virtualbox的附属包</li>
</ul>

<h3 id="section-2">总结</h3>

<p>对于需要影响到kernel的安装的时候， 最好先备份一次VM，避免因为kernel被破坏后难以恢复的问题
对于需要编译kernel module的时候，先查一下已经安装的kernel的开发包有没有多个名称相同但是版本不同的包，如果有则需要删除重复的 
从过程来看，修复是很快的，但是找到问题的根源是复杂的。google也不是万能的。</p>

<p>特定申明：该版权是<a href="&#109;&#097;&#105;&#108;&#116;&#111;:&#032;&#115;&#101;&#097;&#110;&#046;&#103;&#111;&#110;&#103;&#064;&#103;&#109;&#097;&#105;&#108;&#046;&#099;&#111;&#109;">Junjun</a>的 -:)</p>

</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/2/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/03/03/scala-script/">Scala作为脚本语言动态执行</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/03/02/scala211-overview/">Scala211特性简介</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/02/26/ssh-proxy-in-linux/">Ssh在linux下使用http/https代理</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/02/25/sublime-startup/">Sublime入门以及搭建scala开发环境</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/02/23/mac-port-guide/">Mac下port工具的使用</a>
      </li>
    
  </ul>
</section>




<section>
  <h1>Categories</h1>
  <ul id="categories">
    <li class='category'><a href='/blog/categories/appscale/'>Appscale (3)</a></li>
<li class='category'><a href='/blog/categories/auto-test/'>Auto Test (1)</a></li>
<li class='category'><a href='/blog/categories/bing/'>Bing (1)</a></li>
<li class='category'><a href='/blog/categories/centos/'>CentOS (1)</a></li>
<li class='category'><a href='/blog/categories/data-model/'>Data Model (1)</a></li>
<li class='category'><a href='/blog/categories/design-pattern/'>Design Pattern (9)</a></li>
<li class='category'><a href='/blog/categories/docker/'>Docker (1)</a></li>
<li class='category'><a href='/blog/categories/entity-model/'>Entity Model (1)</a></li>
<li class='category'><a href='/blog/categories/fp/'>FP (1)</a></li>
<li class='category'><a href='/blog/categories/findbugs/'>Findbugs (1)</a></li>
<li class='category'><a href='/blog/categories/gsl/'>GSL (1)</a></li>
<li class='category'><a href='/blog/categories/guava/'>Guava (1)</a></li>
<li class='category'><a href='/blog/categories/guice/'>Guice (2)</a></li>
<li class='category'><a href='/blog/categories/integration/'>Integration (1)</a></li>
<li class='category'><a href='/blog/categories/junit/'>JUnit (1)</a></li>
<li class='category'><a href='/blog/categories/java/'>Java (13)</a></li>
<li class='category'><a href='/blog/categories/jekyll/'>Jekyll (1)</a></li>
<li class='category'><a href='/blog/categories/jenkins/'>Jenkins (3)</a></li>
<li class='category'><a href='/blog/categories/linux/'>Linux (1)</a></li>
<li class='category'><a href='/blog/categories/mac/'>MAC (2)</a></li>
<li class='category'><a href='/blog/categories/maven/'>Maven (3)</a></li>
<li class='category'><a href='/blog/categories/miscellany/'>Miscellany (1)</a></li>
<li class='category'><a href='/blog/categories/oo/'>OO (1)</a></li>
<li class='category'><a href='/blog/categories/osx/'>OSX (4)</a></li>
<li class='category'><a href='/blog/categories/octopress/'>Octopress (16)</a></li>
<li class='category'><a href='/blog/categories/plantuml/'>PlantUML (3)</a></li>
<li class='category'><a href='/blog/categories/port/'>Port (2)</a></li>
<li class='category'><a href='/blog/categories/proxy/'>Proxy (2)</a></li>
<li class='category'><a href='/blog/categories/rest/'>REST (3)</a></li>
<li class='category'><a href='/blog/categories/sbt/'>SBT (2)</a></li>
<li class='category'><a href='/blog/categories/scala/'>Scala (7)</a></li>
<li class='category'><a href='/blog/categories/script/'>Script (1)</a></li>
<li class='category'><a href='/blog/categories/sublime/'>Sublime (1)</a></li>
<li class='category'><a href='/blog/categories/uml/'>UML (1)</a></li>
<li class='category'><a href='/blog/categories/virtualbox/'>VirtualBox (1)</a></li>

  </ul>
</section>
<section>
     <h1>About Me</h1>
     <iframe width="100%" height="550" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=2&ptype=1&speed=300&skin=1&isTitle=0&noborder=0&isWeibo=1&isFans=0&uid=1872168377&verifier=1cd3a528&dpc=1"></iframe>
</section>

  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - Duff Qiu -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  












</body>
</html>
