
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Duff Qiu's Blog</title>
  <meta name="author" content="Duff Qiu">


<meta name="msvalidate.01" content="359198A91024370BBF46839C4C26D15C" />


<link href='/assets/global-d3c750679d97597cd5db87fceaa57309.css' rel='stylesheet' type='text/css' />


<script src='/assets/global-3be11d01c576919bb0be36d59a372a9e.js' type='text/javascript'></script>


  
  <meta name="description" content="模版方法模式原理 名称：模版方法(Template Method)模式 问题：在很多时候多个对象有很多个共性，只是某个／某些行为不同，如果单独实现这些对象，则需要很多的copy - paste 解决方案：将共性的行为抽取到抽象类，将特定的行为由具体的对象来实现／或者这个具体的行为本身就是一个对象( &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://duffqiu.github.io">
  <link href="/favicon.png" rel="icon">
<!--
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css"> -->
  <link href="/atom.xml" rel="alternate" title="Duff Qiu's Blog" type="application/atom+xml">
  <!-- <script src="/javascripts/modernizr-2.0.js"></script> -->
  <!-- <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script> -->
  <!-- <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script> -->
  <!-- <script src="/javascripts/octopress.js" type="text/javascript"></script> -->
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href='/assets/global-d3c750679d97597cd5db87fceaa57309.css' rel='stylesheet' type='text/css' />


<script src='/assets/global-3be11d01c576919bb0be36d59a372a9e.js' type='text/javascript'></script>


<!-- <link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css"> -->
<!-- <link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css"> -->

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-47478128-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Duff Qiu's Blog</a></h1>
  
    <h2>Duff Qiu的个人博客，只为记录一个过程，结果都是浮云☁️！</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:duffqiu.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">首页</a></li>
  <li><a href="/blog/categories/java/">Java编程</a><li>
  <li><a href="/blog/categories/uml/">UML Tips</a><li>
  <li><a href="/blog/categories/osx/">OSX经验与Tips</a><li>
  <li><a href="/blog/categories/octopress/">Octopress经验</a><li>
  <li><a href="/blog/archives">全部文章</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/02/03/she-ji-mo-shi-%3Amo-ban-fang-fa/">设计模式：模版方法</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-02-03T14:53:40+08:00" pubdate data-updated="true">Feb 3<span>rd</span>, 2014</time>
        
        
           | <a href="/blog/2014/02/03/she-ji-mo-shi-%3Amo-ban-fang-fa/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3 id="section">模版方法模式原理</h3>

<ol>
  <li>名称：模版方法(Template Method)模式</li>
  <li>问题：在很多时候多个对象有很多个共性，只是某个／某些行为不同，如果单独实现这些对象，则需要很多的copy - paste</li>
  <li>解决方案：将共性的行为抽取到抽象类，将特定的行为由具体的对象来实现／或者这个具体的行为本身就是一个对象(主要由继承方式和回调方式两种实现手段)</li>
  <li>结果：减少了相同的代码，增强了维护性</li>
</ol>

<h3 id="section-1">继承方式实现模版方法模式</h3>

<p><img src="/images/TemplatePattern1.png" alt="继承方式的模版方法" /></p>

<p>这里注意点：
1. 父类是抽象类
2. 抽象方法是个个子类需要实现的各自的具体行为
3. 父类只是实现一个算法框架
4. Java为了避免父类的的方法被覆盖／重写，可以将其申明为final或private</p>

<h3 id="section-2">回调函数实现模版方法模式</h3>

<p><img src="/images/TemplatePattern2.png" alt="回调函数的模版方法" /></p>

<p>这里注意点：
1. 主类对应的接口依赖与回调的接口定义，不是直接依赖回调对象本身
2. 主类无需被继承，提定行为由实现回调接口的对象实现
3. 最为常用的例子是多线程处理中，回调对象都实现了Runable接口实现特性的逻辑，控制线程的主逻辑类如ExecutorService依赖于Runable接口</p>

<p>个人比较建议使用回调函数实现模版方法模式。（之前用C++的时候计较多的是用继承的方式）</p>

<h4 id="vi">Vi小技巧</h4>
<ol>
  <li>yy 用来copy当前行</li>
  <li>数字n＋yy  用来copy从单前行开始的n行</li>
  <li>p 在当前光标出插入copy的内容</li>
</ol>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/02/02/umllei-tu/">UML类图</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-02-02T20:44:44+08:00" pubdate data-updated="true">Feb 2<span>nd</span>, 2014</time>
        
        
           | <a href="/blog/2014/02/02/umllei-tu/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3 id="uml">UML工具</h3>
<p>推荐大家用<a href="http://members.change-vision.com/files/astah_community" title="官网">astah</a>，Community版本就够了</p>

<h3 id="section">类图的描述</h3>

<ol>
  <li>类名：正体字为实例化类， 斜体字是抽象类，接口类有interface标识(也可以是个圆形，不过建议在类图中还是使用长方形的图形标识)</li>
  <li>属性：<strong><em>+</em></strong>表示puiblic， <strong><em>-</em></strong>表示private， <strong><em>#</em></strong>表示protected</li>
  <li>方法：<strong><em>+</em></strong>表示puiblic， <strong><em>-</em></strong>表示private， <strong><em>#</em></strong>表示protected, 有下划线表示      <font style="border-bottom:1px solid #000;">静态方法</font></li>
</ol>

<p><img src="/images/ClassDiagram.png" alt="类图和继承与实现" /></p>

<h3 id="section-1">类图中类与类的关系</h3>

<h4 id="section-2">继承与实现</h4>

<ol>
  <li>
    <p>继承关系，用带实线的闭合空心箭头</p>

    <div style="font-size: 36px"> ⇾ </div>

    <p>表示，Java语言中<strong>extends</strong>体现</p>
  </li>
  <li>
    <p>接口实现关系，用虚线带的闭合空心箭头</p>

    <div style="font-size: 36px"> ­­­­⁃⁃⇾ </div>

    <p>表示，Java语言中<strong>implements</strong>体现</p>
  </li>
</ol>

<h4 id="section-3">关联关系(体现类与类的实例变量的关系)</h4>

<p>提示： 实践中，要将所有的关联关系都要画清楚</p>

<ol>
  <li>
    <p>类与类的关联关系：(association)，体现类与类的实例变量的关系，可以是单向关联（单箭头），也可以是双向关联（双箭头/无箭头，不鼓励有这种关系）。关联关系还可以有个基数，表明这一端的类有几个该类型的实例（0..1, 0..*, 1, 1..*），使用实线开放式箭头表示</p>

    <div style="font-size: 36px"> ➔ </div>
  </li>
  <li>
    <p>聚合关系（aggregation），关联关系的一种，是强的关联关系，是整体和个体间的关系(个体可以单独存在)，也是通过实例变量体现。Java语法是无法区分聚合和关联关系的。如果不是太确定，可以设置为关联关系。同样具有基数。实例类用空的菱形表示  </p>

    <div style="font-size: 36px"> ◇⟶ </div>
  </li>
  <li>
    <p>合成关系(Composition)，关联关系的一种，是比聚合关系<strong>强</strong>的关联关系。该关系和聚合关系的区别是，代表整体的部分负责代表部分的对象的生命周期，即部分对象不会独立于整体存在，且不能共享。实例类用实心的菱形表示，也是通过实例变量体现。如果不是太确定则用聚合/关联关系表示</p>

    <div style="font-size: 36px"> ◆⟶ </div>
  </li>
</ol>

<h4 id="section-4">依赖关系(体现为局部变量、方法参数，以及对静态方法的调用)</h4>

<p>提示： 这些表示在astah中都可以容易使用，要做到的事情时清楚其具体含义 </p>

<ol>
  <li>
    <p>依赖关系(dependency)，依赖总是单向。Java中体现为局部变量、方法参数，以及对静态方法的调用，图形通过虚线开放箭头表示</p>

    <div style="font-size: 36px"> ⤑ </div>

    <p>实践中没有必要将所有的依赖都画出来，只画出重要部分</p>
  </li>
</ol>

<h5 id="astah">类的关联关系和依赖关系在astah中的表示如下：</h5>

<p><img src="/images/ClassRelationship.png" alt="类的关联关系和依赖关系" />   </p>

<p>尽管前面讲了使用UML不要太教条，试用就好，但是图的表示含义还是要准确的好
本章节的astah的文件：<a href="/assets/ClassDiagram.asta">类的UML说明</a></p>

<h3 id="section-5">小插曲</h3>

<p>今天在家下载astah很慢，就用baidu的离线下载（普通下载方式），先交由baidu下载到网盘上，然后再到网盘上下载下来，速度很快，比直接下载好多了</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/02/02/oode-%5B%3F%5D-xie-she-ji-yuan-ze/">OO的一些设计原则</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-02-02T16:05:09+08:00" pubdate data-updated="true">Feb 2<span>nd</span>, 2014</time>
        
        
           | <a href="/blog/2014/02/02/oode-%5B%3F%5D-xie-she-ji-yuan-ze/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3 id="oo">OO设计原则</h3>

<ol>
  <li>
    <p>“开-闭”原则 (Open-Closed Principle, OCP)</p>

    <ul>
      <li>对扩展开放，对修改关闭 (如不要去覆盖一个父类的行为，但是可以在一个新的类的行为中使用父类／关联类的行为)</li>
      <li>不允许更改系统的抽象层，是允许扩展系统的实现层  </li>
    </ul>
  </li>
  <li>
    <p>抽象类(Abstract Class)</p>

    <ul>
      <li>具体类不是用来继承的。继承要从抽象类开始，一般以abstract命名开头</li>
      <li>如果遇到具体类的继承，最有可能的重构方式是构造一个抽象类，这两个类成为这个抽象类的子类</li>
      <li>抽象类应当尽可能有多的共同代码</li>
      <li>抽象类应当尽可能少的数据</li>
      <li>针对抽象编程</li>
      <li>正确使用继承，不要从工具类继承</li>
    </ul>
  </li>
  <li>里氏代换原则(LSP)
    <ul>
      <li>如果程序调用适用于基类，则必定适用于其子类</li>
      <li>反过来的代价不成立</li>
    </ul>
  </li>
  <li>
    <p>依赖倒转原则（DIP）</p>

    <ul>
      <li>要依赖于抽象，不要依赖于具体实现</li>
      <li>三种耦合关系：
  a. 零耦合(Nil Coupling)，两个类没有耦合关系<br />
  b. 具体耦合(Concrete Coupling)，具体型耦合发生在两个具体类之间，有一个类对另一个具体类的直接引用造成（非继承）<br />
  c. 抽象耦合(Abstract Coupling)，耦合关系发生在一个具体类和抽象类（或接口）之间  </li>
      <li>DIP要求客户端依赖于抽象耦合</li>
      <li>抽象不应当依赖于细节，细节应当依赖于抽象</li>
      <li>针对接口编程，不针对实现编程。即使用接口和抽象类进行变量的类型声明、函数参数的类型声明、方法的返回值类型声明，以及数据类型的转换。</li>
      <li>联合使用Java接口和抽象类</li>
      <li>对于已经很稳定的类，客户端是可以依赖于这个具体类型的，而不用再发明抽象类型</li>
    </ul>
  </li>
  <li>接口隔离原则(ISP)
    <ul>
      <li>使用多个专门的接口比使用单一接口要好 </li>
      <li>一个类对于另外一个类的依赖应当建立在最小的接口上</li>
      <li>定制服务：如果客户端仅需要某些方法，那么就应但只提供这些需要的方法，而不提供不需要的方法</li>
    </ul>
  </li>
  <li>合成/聚合复用原则（CARP）  <br />
    <ul>
      <li>在一个新的对象中使用一些已有的对象，新的对象通过向这些旧的对象委派达到复用已有功能的目的</li>
      <li>尽量使用合成/聚合，尽量不要使用继承</li>
    </ul>
  </li>
  <li>迪米特法则(LoD)<br />
又叫做最少知识原则(Least Knowledge Principle LKP)
    <ul>
      <li>只与你直接的朋友通信</li>
      <li>不要和“陌生人”说话</li>
      <li>朋友确定的原则：
        <ul>
          <li>当前对象本身（this）</li>
          <li>以参数形式传入到当前对象方法的对象</li>
          <li>当前对象的实例变量直接引用的对象</li>
          <li>当前对象的实例变量如果是一个聚集，则聚集中的元素都是朋友</li>
          <li>当前对象所创建的对象</li>
        </ul>
      </li>
      <li>使用抽象陌生人重构来调用陌生对象，避免过多的原子调用转发</li>
    </ul>
  </li>
  <li>
    <p>广义迪米特法则在类上的设计</p>

    <ul>
      <li>优先考虑将一个类设置成不变类</li>
      <li>尽量降低一个类的访问权限（package-private是默认权限，无需标示private关键字）</li>
      <li>谨慎使用Serializable</li>
      <li>尽量降低类成员(属性、方法、嵌套类、嵌套接口)的访问权限
        <ul>
          <li>private，只能类内部使用 </li>
          <li>package-private,只能被当前包的类访问，默认权限，无需任何关键字标示</li>
          <li>protected，但前包的类和它的子类可以访问</li>
          <li>public,任何类都可以访问</li>
        </ul>
      </li>
      <li>限制局域变量的有效访问</li>
    </ul>
  </li>
</ol>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/02/02/she-ji-mo-shi-kai-pian/">设计模式开篇</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-02-02T15:31:04+08:00" pubdate data-updated="true">Feb 2<span>nd</span>, 2014</time>
        
        
           | <a href="/blog/2014/02/02/she-ji-mo-shi-kai-pian/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3 id="section">参考</h3>
<p>从这里开始，主要是参考<a href="http://www.amazon.cn/漫谈设计模式-从面向对象开始-刘济华/dp/B006QQZE4Y/ref=sr_1_1?ie=UTF8&amp;qid=1391326331&amp;sr=8-1&amp;keywords=漫谈设计模式">漫谈设计模式</a></p>

<p>要去理解设计模式，必须是有以下基础</p>

<ol>
  <li>语言基础(Java, C++, Object-C…)，这里是以Java语言做介绍，如果需要初步学Java则可以看看<a href="https://www.udemy.com/java-tutorial/?couponCode=FREE">Udemy</a>上面的免费入门视频</li>
  <li>懂得OO的设计理念/原则，后面再抽个章节讲讲这个<a href="/blog/2014/02/02/oode-%5B%3F%5D-xie-she-ji-yuan-ze/">OO的设计原则</a></li>
  <li>懂得UML的基础，入门可以先看看这本简单的<a href="http://www.amazon.cn/系统分析师UML项目实战-邱郁惠/dp/B00DSQZ9IQ/ref=sr_1_1?ie=UTF8&amp;qid=1391326582&amp;sr=8-1&amp;keywords=系统分析师UML项目实战">系统分析师UML项目实战</a>，个人也不太建议UML在工作做过于教条化。之前曾经有1年多都是在画UML图，然后开发依据UML图去做开发，结果效果并不是很好。但是一些基础的比较实际的用法还是值得去做的。要看明白设计模式的类图，请先看看<a href="/blog/2014/02/02/umllei-tu/">UML类图</a></li>
</ol>

<h3 id="gof-23">经典的GoF 23个设计模式，这只是个基础</h3>
<p>GoF的23个设计模式只是一个经典的总结，但是不代表只有23个，其实在工作中很多问题的共性解决方案都有可能编程设计模式，只要复合以下4个基本的设计模式要素</p>

<ol>
  <li>模式名称（Pattern Name）</li>
  <li>问题描述（Problem）</li>
  <li>解决方案（Solution）</li>
  <li>效果／结果（consequence）</li>
</ol>

<h3 id="section-1">模式的套用</h3>
<p>不是说能套上设计模式就是好的设计，好的设计需要多个方面的积累，AOP、BDD、TDD。。。<br />
模式更像是独孤九剑，最后是忘记模式而自然而然的使用模式(好像有些玄乎？)<br />
设计模式的基础还是OO，只有用好OO才能更好的理解和用好设计模式</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/02/02/octopresstian-jia-bingwang-zhan-fen-xi/">Octopress添加bing网站分析</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-02-02T11:30:01+08:00" pubdate data-updated="true">Feb 2<span>nd</span>, 2014</time>
        
        
           | <a href="/blog/2014/02/02/octopresstian-jia-bingwang-zhan-fen-xi/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3 id="section">原由</h3>
<p>Google提供了相应的Analytics网站分析工具，同样Bing也提供了类似的工具：<a href="http://www.bing.com/toolbox/webmaster/" title="官网">Bing网站管理员</a>，同样可以给你的Octopress很快速的添加该分析工具</p>

<h3 id="section-1">配置</h3>

<ol>
  <li>在Bing网站管理员注册，并填写必要的信息</li>
  <li>添加一个新网站，填写相应的信息</li>
  <li>
    <p>根据认证所有权网页配置Octopress，具体如下</p>

    <ul>
      <li>下载你的BingSiteAuth.xml到octopres的source目录下</li>
      <li>
        <p>配置_config_yml文件，设置bing analytics开关，在文件最后加入，如果以后不用bing analytics，则可以将开关设置为false就可以，不用到处改文件</p>

        <pre><code># Bing Analytics  
bing_analytics: true
</code></pre>
      </li>
      <li>
        <p>修改octopres/source/_include目录下的head.html文件，在&lt;head&gt;下面增加以下内容，记得替换&lt;…&gt;bing给你的blog的标识</p>

        <pre><code>{% if site.bing_analytics %}
&lt;meta name="msvalidate.01" content="&lt;...&gt;" /&gt;
{% endif %}
</code></pre>
      </li>
      <li>
        <p>然后重新生成并部署就可以了      </p>

        <pre><code>&gt;rake generate
&gt;rake deploy
</code></pre>
      </li>
    </ul>
  </li>
</ol>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/02/01/port-tips-ruan-jian-ban-ben-xuan-ze/">Port Tips: 软件版本选择</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-02-01T23:30:20+08:00" pubdate data-updated="true">Feb 1<span>st</span>, 2014</time>
        
        
           | <a href="/blog/2014/02/01/port-tips-ruan-jian-ban-ben-xuan-ze/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3 id="port">port查看本地已安装的文件</h3>

<pre><code>&gt;port installed
</code></pre>

<h3 id="port-1">port查看同一个软件的不同版本</h3>

<pre><code>&gt;port select --list python    #这里查看的已经安装了的python的版本
</code></pre>

<p>我的机器情况是：    </p>

<p><img src="/images/Snip20140201_1.png" alt="image" />    </p>

<p>显示为none指的是系统自带的版本</p>

<h3 id="section">激活某个版本</h3>

<pre><code>&gt;sudo port select --set python python2.7
</code></pre>

<p><strong>注意：</strong> 只有那些有对应的select软件包的软件才可以设置版本    </p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/02/01/jia-su-octopressde-zhuang-zai/">加速Octopress的装载</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-02-01T14:23:15+08:00" pubdate data-updated="true">Feb 1<span>st</span>, 2014</time>
        
        
           | <a href="/blog/2014/02/01/jia-su-octopressde-zhuang-zai/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3 id="section">原由</h3>
<p>加速网页的存取有多种方式，其中之一就是减少一个页面的http的请求数量，因为浏览器同时发送http请求的数量是有限的，而对于很多页面而言，通常定义了很多css和js文件的链接，这样就会造成浏览器需要多次请求后才能完整的展示页面，所以最好的方式将多个css和js文件合并，如果需要还可以将合并后的文件压缩再传输，从而达到加速的目的。</p>

<h3 id="gem">Gem插件安装</h3>
<p>Octopress的<a href="https://github.com/matthodan/jekyll-asset-pipeline">jekyll-asset-pipeline</a>就是一个这样机制的开源插件<br />
简单的可以通过以下命令安装</p>

<pre><code>&gt;sudo gem install jekyll-asset-pipeline
</code></pre>

<p><strong>注意：</strong> 有可能安装完成后，需要更新bundle，这行命令</p>

<pre><code>&gt;sudo bunlde update  
</code></pre>

<p>压缩需要用到插件YUI Compressor，可以简单通过以下命令安装</p>

<pre><code>&gt;sudo gem install yui-compressor
</code></pre>

<p>另外一个选择是使用Google的<a href="https://developers.google.com/closure/?hl=zh-cn">Closure</a>，可以通过简单通过以下命令安装</p>

<pre><code>&gt;sudo gem install Closure          
</code></pre>

<h3 id="octopress">配置Octopress</h3>
<ol>
  <li>
    <p>配置octopress目录下的Gemfile文件，在:development中，增加以下两行</p>

    <pre><code>gem "jekyll-asset-pipeline"
gem "yui-compressor
</code></pre>
  </li>
  <li>
    <p>在 Octopress的plugins目录中，创建一个名为“jekyll_asset_pipeline.rb”的文件，内容如下：可以用注释那行代替上面那行就是使用Google的closure来压缩js文件</p>

    <pre><code> require 'jekyll_asset_pipeline'

 module JekyllAssetPipeline
	
   class CssCompressor &lt; JekyllAssetPipeline::Compressor
     require 'yui/compressor'
	
     def self.filetype
       '.css'
     end
	
     def compress
       return YUI::CssCompressor.new.compress(@content)
     end
   end
	
   class JavaScriptCompressor &lt; JekyllAssetPipeline::Compressor
     require 'yui/compressor'
     #require 'closure-compiler'
	
     def self.filetype
       '.js'
     end
	
     def compress
       return YUI::JavaScriptCompressor.new(munge: true).compress(@content)
       #return Closure::Compiler.new.compile(@content)
     end
   end
	
 end
</code></pre>
  </li>
  <li>
    <p>修改Octopress的配置文件_config.yml，在文件最后增加以下配置</p>

    <pre><code>asset_pipeline:
   bundle: true            # Default = true
   compress: true          # Default = true
   #output_path: assets     # Default = assets
   #display_path: nil       # Default = nil
   gzip: false             # Default = false
</code></pre>
  </li>
  <li>
    <p>修改相应的html文件，激活js/css文件的合并压缩。不同的Octopress的template，对应的文件或有不同，我这里用的是Octopress默认的官方template，因该适合大多数人</p>

    <ul>
      <li>
        <p>修改source/_include目录下的head.html文件，注释掉带有js/css的几行</p>

        <pre><code> &lt;!-- &lt;link href="{{ root_url }}/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css"&gt; --&gt;
	 
 &lt;!-- &lt;script src="{{ root_url }}/javascripts/modernizr-2.0.js"&gt;&lt;/script&gt; --&gt;
 &lt;!-- &lt;script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"&gt;&lt;/script&gt; --&gt;
 &lt;!-- &lt;script&gt;!window.jQuery &amp;&amp; document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))&lt;/script&gt; --&gt;
 &lt;!-- &lt;script src="{{ root_url }}/javascripts/octopress.js" type="text/javascript"&gt;&lt;/script&gt; --&gt;
</code></pre>
      </li>
      <li>
        <p>增加以下内容</p>

        <pre><code>{% css_asset_tag global %}
 - /stylesheets/screen.css
{% endcss_asset_tag %}
	
{% javascript_asset_tag global %}
- /javascripts/octopress.js
- /javascripts/modernizr-2.0.js
- /javascripts/libs/jquery.min.js
- /javascripts/libs/swfobject-dynamic.js
- /javascripts/libs/jXHR.js
{% endjavascript_asset_tag %}
</code></pre>
      </li>
      <li>
        <p>同理修改source/_includes/custom目录下的head.html文件，注释掉里面的内容，增加上面的内容就可   </p>
      </li>
    </ul>
  </li>
  <li>
    <p>到底有多css和js文件需要加入到需要增加的内容中呢？在octopress/source目录中搜索一下</p>

    <pre><code>find . -name '*.css'
find . -name '*.js'
</code></pre>

    <p>然后将必要的文件加入到上面的文件列表中</p>
  </li>
</ol>

<h3 id="vi">Vi小提示</h3>

<ol>
  <li>跳到文件头用 “:0”</li>
  <li>跳到行头在非编辑状态下直接收入”0”</li>
  <li>跳到行尾在非编辑状态下直接收入”$”      </li>
</ol>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/02/01/octopresstong-zhi-sou-suo-yin-qing/">Octopress通知搜索引擎</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-02-01T13:21:02+08:00" pubdate data-updated="true">Feb 1<span>st</span>, 2014</time>
        
        
           | <a href="/blog/2014/02/01/octopresstong-zhi-sou-suo-yin-qing/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3 id="section">目的</h3>
<p>每次更新blog后，总希望搜索引擎可以尽快收录到，最好是多个搜索引擎都能收入到<br />
怎么做到呢？</p>

<h3 id="rake">配置搜索引擎rake任务</h3>
<p>首先感谢原作者的介绍<a href="http://blog.eavatar.com/post/2013/06/octopress-ping-search-engines/">1</a></p>

<ol>
  <li>
    <p>编辑octopress目录的Rakefile文件，在最后增加搜索引擎任务</p>

    <pre><code>＃Google search engine
desc 'Notify Google of the new sitemap'
 task :sitemapgoogle do
  begin
    require 'net/http'
    require 'uri'
    puts '* Pinging Google about our sitemap'
    Net::HTTP.get('www.google.com', '/webmasters/tools/ping?sitemap=' + URI.escape('http://duffqiu.github.io/sitemap.xml'))
  rescue LoadError
    puts '! Could not ping Google about our sitemap, because Net::HTTP or URI could not be found.'
  end
 end

#Baidu search engine       
desc 'Ping Baidu'
 task :pingbaidu do
   begin
     require 'xmlrpc/client'
     puts '* Pinging Baidu search engine'
     XMLRPC::Client.new('ping.baidu.com', '/ping/RPC2').call('weblogUpdates.extendedPing', 'duffqiu.github.io' , 'http://duffqiu.github.io', 'http://duffqiu.github.io', 'http://duffqiu.github.io/rss.xml')
   rescue LoadError
     puts '! Could not ping Baidu, because XMLRPC::Client could not be found.'
   end
 end
	
#Bing search engine
desc 'Notify Bing of the new sitemap'
 task :sitemapbing do
   begin
     require 'net/http'
     require 'uri'
     puts '* Pinging Bing about our sitemap'
     Net::HTTP.get('www.bing.com', '/webmaster/ping.aspx?siteMap=' + URI.escape('http://duffqiu.github.io/sitemap.xml'))
   rescue LoadError
     puts '! Could not ping Bing about our sitemap, because Net::HTTP or URI could not be found.'
   end
 end	
</code></pre>

    <p>将”duffqiu.github.io”换成你的blog域名字即可</p>
  </li>
  <li>
    <p>增加一个批量任务同时执行三个通知</p>

    <pre><code>desc "Notify various services about new content"
task :notify =&gt; [:sitemapgoogle, :sitemapbing, :pingbaidu] do
end
</code></pre>
  </li>
  <li>
    <p>每次部署后执行命令</p>

    <pre><code>rake notify
</code></pre>
  </li>
</ol>

<h3 id="vi">vi小技巧</h3>
<p>今天有用到一个vi的命令，跳转到文件最后用”:$”        </p>

<h3 id="section-1">小插曲</h3>
<p>今天发现用Mac OSX10.9可以直接投射屏幕到小米盒子(v1.3.20)了</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/01/30/octopress-gemcha-jian-gslan-zhuang/">Octopress Gem插件gsl安装</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-01-30T20:00:10+08:00" pubdate data-updated="true">Jan 30<span>th</span>, 2014</time>
        
        
           | <a href="/blog/2014/01/30/octopress-gemcha-jian-gslan-zhuang/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3 id="section">原由</h3>
<p>Octopress用rake generate的时候会提示使用GSL将会加速文件的生成，速度是原来的的10+倍，但是需要安装<a href="http://rb-gsl.rubyforge.org/">Ruby GSL</a>插件。</p>

<h3 id="section-1">安装</h3>
<p>当使用命令安装Ruby GSL的时候确发现了问题 </p>

<pre><code>gem install gsl
</code></pre>

<p>原因是缺少了<a href="http://www.gnu.org/software/gsl/" title="GSL Library官网">GSL的C的开发库</a>    </p>

<p>然后在GSL Library官网下载了最新的GSL1.16，然后编译安装，然后再重新安装Ruby GSL，但是还是出现错误，后来搜索<a href="stackoverflow.com">stackoverflow</a>找到一个说明，说是GSL和Ruby GSL配合的版本只能用1.14的。所以再次下载GSL1.14编译、安装然后再安装Ruby GSL就可以了</p>

<h3 id="section-2">使用</h3>

<pre><code>rake notify
</code></pre>

<p>目前看除了rake generate没有那个提示，好像速度没有看出来，或许是文章的数目不多体现不出来 </p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/01/30/octopressde-nei-bu-blogjian-guan-lian/">Octopress的内部blog间关联</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-01-30T18:28:34+08:00" pubdate data-updated="true">Jan 30<span>th</span>, 2014</time>
        
        
           | <a href="/blog/2014/01/30/octopressde-nei-bu-blogjian-guan-lian/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3 id="section">首先鸣谢参考资料的作者</h3>

<p>参考资料来自与 <a href="http://blog.eavatar.com/post/2013/06/use-post-url-internal-link-octopress/">1</a></p>

<h3 id="octopress">完善Octopress的配置</h3>

<ol>
  <li>
    <p>获取内部关联的<a href="https://raw.github.com/michael-groble/jekyll/fix_post_url/lib/jekyll/tags/post_url.rb">post url plugin</a>，然后将其放入到plugin目录中    </p>
  </li>
  <li>
    <p>确保已经安装了kramdown，如果没有，用以下命令安装</p>

    <pre><code>&gt;sudo gem install kramdown
</code></pre>
  </li>
  <li>
    <p>编辑配置文件_configy.yml，注释掉markdown: rdiscount，然后增加</p>

    <pre><code>#markdown: rdiscount
markdown: kramdown
</code></pre>
  </li>
</ol>

<h3 id="blog">在blog中使用关联，语法如下</h3>

<pre><code>[&lt;链接名字&gt;]({% post_url &lt;blog的文件名字，不要带目录和文件后缀&gt; %}) 
</code></pre>

<p>然后重新生成和部署就可以了</p>

<pre><code>&gt;rake generate
&gt;rake deploy
</code></pre>

<h3 id="section-1">一个小插曲</h3>
<p>今天在生成地8个blog后，rake generate就出错了，报在matrix.rb文件中反馈出”Not Regular Matrix”错误，但是就是死活找不到问题所在，只要将刚生成的文件删除就好了，而文件还没写东西。后来经历反复的从头再来，终于发现了问题所在，结论是之前参照网上配置关联blog的配置，在_configy.yml中增加了以下配置：</p>

<pre><code>lsi: true    
</code></pre>

<p>只要将这个选项关闭或删除就可，好像octopress已经没有用了</p>

<h3 id="octopress-1">Octopress经验总结</h3>

<p>尽管使用上就是用markdown的方式写文章，但是使用octopress这个平台，就像使用开发工具一样，总会出现这样那样的错误，而且还很难定位，最好的办法就是像编程一样，今早“编译”－》“试运行”－》“改错”－》“再运行”，不然当你写了很多后一次行生成出现错误就无从下手去解决问题了，只能一个一个做减法然后再试。</p>

<p>最好的方式是</p>

<ol>
  <li>写一部分，就立马rake generate  </li>
  <li>rake new_post[“<文章名>&#8221;]，不写任何东西，立马rake generate</文章名></li>
  <li>只要用到 {%  %}这些内嵌语法，立马rake generate</li>
  <li>更改一项_config.yml配置，立马rake generate</li>
</ol>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/2/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/02/03/she-ji-mo-shi-%3Amo-ban-fang-fa/">设计模式：模版方法</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/02/02/umllei-tu/">UML类图</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/02/02/oode-%5B%3F%5D-xie-she-ji-yuan-ze/">OO的一些设计原则</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/02/02/she-ji-mo-shi-kai-pian/">设计模式开篇</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/02/02/octopresstian-jia-bingwang-zhan-fen-xi/">Octopress添加bing网站分析</a>
      </li>
    
  </ul>
</section>




<section>
  <h1>Categories</h1>
  <ul id="categories">
    <li class='category'><a href='/blog/categories/bing/'>Bing (1)</a></li>
<li class='category'><a href='/blog/categories/design-pattern/'>Design Pattern (2)</a></li>
<li class='category'><a href='/blog/categories/gsl/'>GSL (1)</a></li>
<li class='category'><a href='/blog/categories/java/'>Java (3)</a></li>
<li class='category'><a href='/blog/categories/jekyll/'>Jekyll (1)</a></li>
<li class='category'><a href='/blog/categories/mac/'>MAC (2)</a></li>
<li class='category'><a href='/blog/categories/oo/'>OO (1)</a></li>
<li class='category'><a href='/blog/categories/osx/'>OSX (3)</a></li>
<li class='category'><a href='/blog/categories/octopress/'>Octopress (10)</a></li>
<li class='category'><a href='/blog/categories/port/'>Port (1)</a></li>
<li class='category'><a href='/blog/categories/proxy/'>Proxy (1)</a></li>
<li class='category'><a href='/blog/categories/uml/'>UML (1)</a></li>

  </ul>
</section>
<section>
     <h1>About Me</h1>
     <iframe width="100%" height="550" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=2&ptype=1&speed=300&skin=1&isTitle=0&noborder=0&isWeibo=1&isFans=0&uid=1872168377&verifier=1cd3a528&dpc=1"></iframe>
</section>

  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Duff Qiu -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  












</body>
</html>
