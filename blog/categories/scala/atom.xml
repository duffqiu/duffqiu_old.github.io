<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Scala, | Duff Qiu's Blog]]></title>
  <link href="http://duffqiu.github.io/blog/categories/scala/atom.xml" rel="self"/>
  <link href="http://duffqiu.github.io/"/>
  <updated>2015-02-23T16:41:47+08:00</updated>
  <id>http://duffqiu.github.io/</id>
  <author>
    <name><![CDATA[Duff Qiu]]></name>
    <email><![CDATA[duffqiu@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[初学sbt]]></title>
    <link href="http://duffqiu.github.io/blog/2015/02/10/sbt-for-new-user/"/>
    <updated>2015-02-10T15:22:32+08:00</updated>
    <id>http://duffqiu.github.io/blog/2015/02/10/sbt-for-new-user</id>
    <content type="html"><![CDATA[<h3 id="section">原由</h3>
<hr />
<p>初学一种语言最烦的就是搭建开发环境了，每次都要装一堆的plugin，有时候又因为不同的plugin的版本等问题冲突
前面介绍如何使用Maven来搭建开发环境，总体而言还算比较复杂。特别是在不同的机器上竟然有些plugin不可用，也不知道问题在那里。
所以既然是以开发Scala为主，那还是用<a href="http://scala-sbt.org">SBT</a>吧</p>

<h3 id="section-1">主要参考</h3>
<hr />
<p>直接参考<a href="http://www.scala-sbt.org/0.13/tutorial/index.html">SBT官网的Getting Started</a>并结合自己的一些实践做了下浓缩
官网已经提供中文版本了(开来中国是用Scala增长比较快的地区，另一个是美国硅谷，有兴趣可以看看google trend上关于Scala)</p>

<p>该Getting Started有几章可以暂时不用看的，到真的有需要再看
- Scope
- Multi-project builds
- Custom settings and tasks
- .scala build definition</p>

<p>另外在Github上有个<a href="https://github.com/n8han/giter8">giter8，简称g8</a>的工具，可以帮助获取scala, sbt的模版，不过自从有了<a href="http://typesafe.com/get-started">typesafe的activator</a>后，提供g8模版已经不多了，原有的模版也没怎么更新了</p>

<h4 id="sbt">安装SBT</h4>
<p>可以根据SBT官网的Getting Started，对于不同的平台采用不同的安装方式
安装完后，基本上就是一个sbt的命令脚本和sbt-launch.jar
安装完后，通过命令行运行一次<code>sbt</code>，然后sbt会将对应的依赖包下载下来。
sbt会在用户的home目录下创建.sbt和.ivy2的目录，依赖包都放在了ivy2的目录里。因为sbt实际是通过ivy2来管理包依赖。不过大家不用去看ivy2，这些都是sbt自己管理的。
如果是公司有代理的环境中，则需要设置java代理的参数才可以使用，不然sbt总是在尝试下载依赖包。
一般设置java代理的参数是在shell的文件中设置JAVA_OPTS,但是好像不其作用。所以最好的方式是直接修改sbt的命令脚本增加代理配置参数</p>

<p><code>sh
JAVA_OPTS="$JAVA_OPTS -Dhttp.proxyHost=&lt;proxy host&gt; -Dhttp.proxyPort=&lt;proxy port&gt; -Dhttps.proxyHost=&lt;proxy host&gt; -Dhttps.proxyPort=&lt;proxy port&gt;"
</code></p>

<h4 id="scalajava">建立一个scala/java工程</h4>
<p>建议不要从参考SBT官网的Getting Started的hello world，因为它将源文件建在了工程的根目录上了
很奇怪，到目前位置都没有个一个像maven那样可以直接在Eclipse上创建一个sbt的工程，而必须先手工创建一些文件</p>

<p>具体步骤为：</p>

<ul>
  <li>创建一个工程目录如： sbt-sample</li>
  <li>在工程目录下再创建一个子目录，必须名为project</li>
  <li>在工程目录下创建名为build.sbt的定义文件，并写入基本的信息，需要注意的是每个配置都要空一行。以后打开别人的工程先看看这个文件的基本定义，特比是scala的版本</li>
</ul>

<p>``` sh
name := “sbt-sample”</p>

<p>version := “1.0”</p>

<p>scalaVersion := “2.11.4”</p>

<p>organization := “org.duff”
```
- 使用<a href="https://github.com/typesafehub/sbteclipse">sbteclpise</a>插件， 在project子目录下创建一个plugins.sbt文件，然后加入一下内容，然后在sbt的命令行下执行<code>eclipse</code>就可以生成对应的eclipse的工程了。如果改动了sbt的文件则最后重新执行一次<code>eclipse</code>获得最新的包依赖等</p>

<p><code>sh
addSbtPlugin("com.typesafe.sbteclipse" % "sbteclipse-plugin" % "2.5.0")
</code></p>

<ul>
  <li>打开Eclipse，写个测试的App</li>
</ul>

<p>``` java
package org.duff.sbtsample</p>

<p>object Main extends App{</p>

<p>println(“this is a sbt sample”)</p>

<p>}</p>

<p>```</p>

<ul>
  <li>
    <p>在sbt命令行下执行<code>compile</code>，然后<code>run</code>就可以看到对应的输入了</p>
  </li>
  <li>
    <p>设置包依赖仓库（repository）。对于Maven是设置的Maven的conf文件中，但是对于SBT是每次定义在项目的build.sbt文件中</p>

    <ul>
      <li>方法一： 通过URL定义如： <code>resolvers += "&lt;rep name&gt;" at "&lt;rep url&gt;"</code></li>
    </ul>
  </li>
</ul>

<p><code>sh
resolvers += 
  "Sonatype OSS Snapshots" at "https://oss.sonatype.org/content/repositories/snapshots"
</code></p>

<ul>
  <li>
    <p>方法二： 使用<a href="http://www.scala-sbt.org/0.13/docs/Resolvers.html">预定义的Rep</a>，主要有：</p>

    <ul>
      <li>DefaultMavenRepository at  https://repo1.maven.org/maven2/，这个会被默认使用，无需指定</li>
      <li>JavaNet1Repository  at http://download.java.net/maven/1/</li>
      <li>Resolver.sonatypeRepo(“public”) (or “snapshots”, “releases”) at https://oss.sonatype.org/content/repositories/public</li>
      <li>Resolver.typesafeRepo(“releases”) (or “snapshots”) at https://repo.typesafe.com/typesafe/releases</li>
      <li>Resolver.typesafeIvyRepo(“releases”) (or “snapshots”) at https://repo.typesafe.com/typesafe/ivy-releases</li>
      <li>Resolver.sbtPluginRepo(“releases”) (or “snapshots”) at https://repo.scala-sbt.org/scalasbt/sbt-plugin-releases</li>
      <li>Resolver.bintrayRepo(“owner”, “repo”) at https://dl.bintray.com/[owner]/[repo]/</li>
      <li>Resolver.jcenterRepo at https://jcenter.bintray.com/</li>
    </ul>
  </li>
</ul>

<p><code>sh
resolvers += JavaNet1Repository
</code></p>

<ul>
  <li>方法三：同时指定多个rep，使用<code>resolvers ++= Seq(&lt;rep1&gt;, &lt;rep2&gt;)</code>, rep1/rep2可以使用方法一或方法二</li>
</ul>

<p><code>sh
resolvers ++= Seq(Resolver.sonatypeRepo("public"),
    Resolver.typesafeRepo("releases"))
</code></p>

<ul>
  <li>指定工程依赖包，和resolver类似，可以一个一个指定(+=)，也可以同时指定(++= Seq())，另外如果需要对多个包使用同一个变量指定如scala版本等，则可以使用如下例子的方式(即Scala的闭包)</li>
</ul>

<p><code>
libraryDependencies ++= {
  val akkaVersion       = "2.3.9"
  val sprayVersion      = "1.3.2"
  Seq(
    "com.typesafe.akka" %% "akka-slf4j"      % akkaVersion withSources() withJavadoc(),
    "ch.qos.logback"    %  "logback-classic" % "1.1.2",
    "com.typesafe.akka" %% "akka-testkit"    % akkaVersion   % "test",
    "org.scalatest"     %% "scalatest"       % "2.2.0"       % "test" withSources() withJavadoc()
  )
}
</code>
   - 每个lib的定义格式为 <code>&lt;groupID&gt; % &lt;artifactID&gt; % &lt;revision&gt; % configuration</code>。如上面的 ch.qos.logback，默认情况下都是”compile”的配置，而对于scalatest是指定在”test”的时候才使用
   - 如果artifactID是根据scala的版本有不同的版本则可以简化的使用%%的方式省去指定xxx_2.11.4 (使用scala 2.11.4)而是直接写xxx
   - 需要同时下载javadoc和source，则可以在最后用withSources() withJavadoc()</p>

<ul>
  <li>
    <p>更改完后，如果还在sbt命令行下，则可以运行<code>reload</code>来更新相应的配置</p>
  </li>
  <li>
    <p>打包程序，如果使用的不同的framework/toolkit，则有不同的打包方式，一般的打包方式是打成大的jar包</p>

    <ul>
      <li>配置打包plugin，在project子目录中增加一个名为assembly.sbt的文件，增加以下内容</li>
    </ul>
  </li>
</ul>

<p><code>
addSbtPlugin("com.eed3si9n" % "sbt-assembly" % "0.12.0")
</code>
   - 然后就可以在sbt命令行下执行<code>assembly</code>，则可以打包出jar文件了。可以在子目录target/scala-2.11/下找到这个jar
   - 通过执行<code>java -jar &lt;xxx.jar&gt;</code>来执行程序
   - 可以通过在build.sbt中增加以下配置更改打包jar</p>

<pre><code>   - `ssemblyJarName in assembly := "&lt;xxxx.jar&gt;"` 更改打包的jar文件名
   - `mainClass in assembly := Some("&lt;com.example.Main&gt;")` 更改main函数的入库
   - 如果像用工程的版本号来合成打包文件，则可以这样写 `assemblyJarName in assembly := "&lt;name&gt;" + version.value +".jar"`
</code></pre>

<p>到此一个就本的sbt的scala开发环境就建成了。
后续不同的项目的变化基本上就集中在增加新的依赖包，增加不同的plugin来执行不同的任务
个人使用看来，对比maven相对而言要简单一些。只是SBT使用场景基本只局限于java和scala，同时sbt的写法是scala语法</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Scala中函数式编程还是命令式编程]]></title>
    <link href="http://duffqiu.github.io/blog/2015/02/05/fp-or-imperative-with-scala/"/>
    <updated>2015-02-05T11:44:46+08:00</updated>
    <id>http://duffqiu.github.io/blog/2015/02/05/fp-or-imperative-with-scala</id>
    <content type="html"><![CDATA[<h3 id="section">原由</h3>
<hr />
<p>Scala是即支持传统的命令式编程也支持函数式编程(FP)，我们既可以像java那样写代码，也可以像Lisp那样写。
但是那种好呢？</p>

<h3 id="section-1">解决办法</h3>
<hr />
<p>个人的理解是，主要取决于对问题的解决方式的思路。
如果已经习惯了命令式编程的思路，那就用命令式编程好了。
不过既然FP已经逐渐成为潮流，那换换思路也未尝不可。
从Scala语言本身看两者没有冲突</p>

<h3 id="section-2">一个例子来对比两种思路</h3>
<hr />

<p>例子：有一个Map的数组/列表，要将不同Map中相同key的value值相加，最后得到一个Map</p>

<p><code>java
Vector(Map("test" -&gt; 1, "hello" -&gt; 2, "wwww" -&gt; 9), Map("test" -&gt; 3, "hello" -&gt; 5, "http" -&gt; 33))
</code>
期望得到的结果</p>

<p><code>java
Map(test -&gt; 4, hello -&gt; 7, wwww -&gt; 9, http -&gt; 33)
</code></p>

<ul>
  <li>命令式编程方式
思路：循环Vector中的每个Map，然后循环Map中的每个Key-Value，将相同的Key对应的Value加起来后存入到一个临时的Map，最后返回这个Map</li>
</ul>

<p>``` java
def merge(input: Vector[Map[String, Int]]) = {</p>

<p>var mergeRes = input.head
  val temp = input.tail</p>

<p>for(itr &lt;- temp) {
  	for((word, count) &lt;- itr) {
  		mergeRes = mergeRes + (word -&gt; (mergeRes.get(word).getOrElse(0) + count))
  	}
  }</p>

<p>mergeRes
}
```</p>

<ul>
  <li>函数式编程方式
思路：对于Vector作折叠操作(reduceLeft)，因为每此计算都要以上一次计算作为输入。而计算中需要做的操作由使用者控制。同时对于每个Map都需要操作每个key-value并返回新的key-value所以用到map函数</li>
</ul>

<p><code>java
  def mergeFP(input: Vector[Map[String, Int]]) = {
    input.reduceLeft {
      (el, acc) =&gt;
        el.map {
          case (word, count) =&gt;
            acc.get(word).map(accCount =&gt; (word -&gt; (accCount + count))).getOrElse(word -&gt; count)
        } ++ (acc -- el.keys)
    }
  }
</code></p>

<p>从两者的对比俩看，如果不是熟悉FP的思路的化，似乎FP的代码更难看些。这也是为什么有人认为FP不利于代码沟通的原因吧。
但是从FP的实现看，中间没有任何可变变量（其实Scala对于reduceLeft用了中间可变变量，只是对于函数的使用者不需要了）</p>

<p><strong>注</strong> 改FP的例子载自Akka in Action，但是它的是foldLeft不是reduceLeft</p>

]]></content>
  </entry>
  
</feed>
