
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Duff Qiu's Blog</title>
  <meta name="author" content="Duff Qiu">


<meta name="msvalidate.01" content="359198A91024370BBF46839C4C26D15C" />


<link href='/assets/global-bf22553a6259b19a898e5f2ce32a6188.css' rel='stylesheet' type='text/css' />


<script src='/assets/global-1ae286654142297648bf164d97e30542.js' type='text/javascript'></script>


  
  <meta name="description" content="原由 从CoreOS 682.1开始，ETCD2已经被默认安装了，通过Clould Init的方式在Openstack上启动CoreOS时发生了一些错误，总结如下 解决办法 ETCD2总是启动不成功，通过journalctl _EXE=/usr/bin/coreos- &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://duffqiu.github.io/blog/page/2">
  <link href="/favicon.png" rel="icon">
<!--
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css"> -->
  <link href="/atom.xml" rel="alternate" title="Duff Qiu's Blog" type="application/atom+xml">
  <!-- <script src="/javascripts/modernizr-2.0.js"></script> -->
  <!-- <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script> -->
  <!-- <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script> -->
  <!-- <script src="/javascripts/octopress.js" type="text/javascript"></script> -->
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href='/assets/global-71ba5630485a49609bb34878937506b0.css' rel='stylesheet' type='text/css' />


<script src='/assets/global-1ae286654142297648bf164d97e30542.js' type='text/javascript'></script>


<!-- <link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css"> -->
<!-- <link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css"> -->

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-47478128-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Duff Qiu's Blog</a></h1>
  
    <h2>Duff Qiu的个人博客，只为记录一个过程，结果都是浮云☁️！</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:duffqiu.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">首页</a></li>
  <li><a href="/blog/categories/java/">Java编程</a><li>
  <li><a href="/blog/categories/scala/">Scala编程</a><li>
  <li><a href="/blog/categories/uml/">UML Tips</a><li>
  <li><a href="/blog/categories/osx/">OSX经验与Tips</a><li>
  <li><a href="/blog/categories/octopress/">Octopress经验</a><li>
  <li><a href="/blog/archives">全部文章</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/07/05/coreos-etcd2/">CoreOS Etcd2</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-07-05T16:13:19+08:00" pubdate data-updated="true">Jul 5<span>th</span>, 2015</time>
        
        
           | <a href="/blog/2015/07/05/coreos-etcd2/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3 id="section">原由</h3>
<hr />
<p>从CoreOS 682.1开始，ETCD2已经被默认安装了，通过Clould Init的方式在Openstack上启动CoreOS时发生了一些错误，总结如下</p>

<h3 id="section-1">解决办法</h3>
<hr />

<ul>
  <li>ETCD2总是启动不成功，通过<code>journalctl _EXE=/usr/bin/coreos-cloudinit</code>查看发现其提示没有发现本地的文件有相关的member信息。究其原因是我在cloudinit中设置了etcd2的文件路径，而改文件目录默认是root的权限，但是etcd2运行的时候是以etcd用户运行的，所以造成无法访问改文件目录而启动失败</li>
  <li>解决的办法是通过在cloudinit中写一个oneshot的systemd的服务，该服务将这个目录的权限和所有权更改为etcd，可参照我github上的<a href="https://raw.githubusercontent.com/duffqiu/coreos-openstack/master/etcd2/cloud-config-front1.yaml">cloudinit的例子</a></li>
  <li>另外需要注意的是，etcd2通过discovery指定的cluster的大小。如果没有满足这个cluster的大小的节点联入则etcd2的集群是无法启动的</li>
  <li>etcd2的cluster，在接入节点满足cluster指定的大小后，后续的接入节点将自动降格为proxy模式</li>
  <li>etcdctl可以用<code>--debug</code>开查看发出的CURL命令是什么</li>
</ul>

<h4 id="docker-tips">Docker tips</h4>

<ul>
  <li>从Docker 1.6开始，docker可以支持查看container的运行时的CPU和Memery的消耗，以下命令为列出本机所有containter的运行状况</li>
</ul>

<p>docker stats $(docker inspect –format=”{{ .Name }}” $(docker ps -q))</p>

<ul>
  <li>从Docker 1.6开始，docker支持直接使用命令进入到container中进行交互，而不用向以前那么麻烦的使用nsenter的方式了，具体用法是</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="sh"><span class="line">docker <span class="nb">exec</span> -it &lt;containter name&gt; &lt;<span class="nb">command </span>in container&gt;
</span></code></pre></td></tr></table></div></figure></notextile></div>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/07/05/coreos-keepalived/">CoreOS安装和使用Keepalived</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-07-05T15:43:47+08:00" pubdate data-updated="true">Jul 5<span>th</span>, 2015</time>
        
        
           | <a href="/blog/2015/07/05/coreos-keepalived/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3 id="section">原由</h3>
<hr />
<p>在之前的文章<a href="/blog/2015/07/05/openstack-vip/">Openstack用Keealived来实现VIP</a>介绍了如何使用Keepalived来实现VIP，但是如果使用的vm是CoreOS，所有的程序又必须运行在Docker中的话，又该如何办呢？</p>

<h3 id="section-1">解决办法</h3>
<hr />

<ul>
  <li>将Keepalived做成一个Docker的image，如果需要可以自己下载keepalived的源码编译出可执行文件。因为只是用到VIP特性，可以在编译的时候将IPVS去掉（该功能可以使用haproxy代替）。一个比较偷懒的办法是先用yum的方式安装keepalived(基于CentOS)<code>yum install keepalived</code>，然后用<code>rpm -e --nodeps keepalived</code>去掉安装的可执行文件而是用自己编译的可执行文件。不然的话就需要一个一个指定的方式来安装keepalived需要的依赖包了</li>
  <li>查看CoreOS的内核是否已经启动ip_vs模块<code>lsmod</code>。似乎从681.2开始，默认都已经启动了，之前的版本没有默认启动</li>
  <li>如果没有启动ip_vs，则可以通过<code>sudo modprobe -a ip_vs</code>来加载</li>
  <li>使用<code>--priviliedged</code>和<code>--net=host</code>的方式来启动keepalived</li>
  <li>具体的docker file可以参考我的github上的<a href="https://github.com/duffqiu/keepalived">repo</a></li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/07/05/openstack-vip/">Openstack用Keealived来实现VIP</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-07-05T15:34:52+08:00" pubdate data-updated="true">Jul 5<span>th</span>, 2015</time>
        
        
           | <a href="/blog/2015/07/05/openstack-vip/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3 id="section">原由</h3>
<hr />
<p>在Openstack创建VM的时候一般都是使用DHCP的方式来分配虚拟机的IP地址。这样就会出现一个问题，每次重建VM的时候，IP地址都会被改变，从而影响外部的访问。同时如果期望有两个虚拟机同时服务一个IP接入的话，则需要用到VIP的方式来实现。</p>

<h3 id="section-1">解决办法</h3>
<hr />

<p>VIP的实现方式通常使用VRRP（Virtual Router Redundancy Protocol）协议的方式。目前开源比较通用的软件是<a href="http://keepalived.org/">Keepalived</a>，但是在Openstack的环境中，并不是在两台虚拟机安装了Keepalived就可以的。而是需要做某些配置，下面具体讲讲</p>

<ul>
  <li>在OpenStack的一个内部网络上创建一个Port，这个Port将得到一个内网的IP <code>neutron port-create --name &lt;port name&gt; &lt;internal network name&gt;</code> 。如果不知道openstack上有哪些网络可用，则可以用<code>neutron net-list</code>来查看</li>
  <li>创建一个外网可访问的floating ip。<code>neutron floatingip-create &lt;external network name&gt;</code></li>
  <li>将这个floating ip关联到这个新建的port上。 <code>neutron floatingip-associate &lt;floating ip uuid&gt; &lt;port uuid&gt;</code>。这样就可以通过外部网络访问到这个port口了。</li>
  <li>启动两台VM，然后各自配置keepalived，并且用这个内网的ip作为VIP给keepalvied使用。配置好后，似乎都没有问题了。但是始终无法访问，原因是openstack对于使用VIP有安全限制，必须认为的将这个VIP与VM关联才可以访问</li>
  <li>配置VM的allowed-address-pair。首先通过<code>nova list |grep &lt;vm identity&gt;</code>来找到自己创建的VM，然后通过<code>neutron port-list|grep &lt;vm ip&gt;</code>来找到VM port对应的uuid。通过<code>neutron port-show &lt;vm port uuid&gt;</code>来查看是否配置了allowed-address-pair。如果没有则需要更新port来支持allowed-address-pair。命令是<code>neutron port-update &lt;vm port uuid&gt; --allowed-address-pairs type=dict list=true ip_address=&lt;VIP&gt;</code></li>
</ul>

<h3 id="section-2">如何调试</h3>

<ul>
  <li>如果一切都配置好了，但是就是无法通，则可以在VM或者是Openstack对应的Computer Node上用<code>tcpdump -i &lt;net card name&gt; icmp</code>的方式开跟踪是否消息包是通的</li>
  <li><code>ip neigh |grep &lt;vip&gt;</code> 来查看<vip>对应的mac地址。然后在作为master的keepalived的机器上看看是否是这个mac地址</vip></li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/03/29/install-coreos/">CoreOS的安装</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-03-29T11:10:44+08:00" pubdate data-updated="true">Mar 29<span>th</span>, 2015</time>
        
        
           | <a href="/blog/2015/03/29/install-coreos/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3 id="section">原由</h3>
<hr />
<p>想玩Docker的人肯定应该听说过<a href="https://coreos.com">CoreOS</a>。它是一个紧密结合Docker为大集群服务器而设计的Linux系统。它本身不允许安装软件包。所有提供的功能和扩展都是通过Docker容器来提供。安装CoreOS可以有多种方式，网管上都有介绍。这里主要说一下两种方式，一种是单机版，一种是服务器集群。这两种方式都是基于VirtualBox的安装.</p>

<h3 id="coreos">单机安装CoreOS</h3>
<hr />

<ul>
  <li>配置Virtualbox，创建一个linux的虚拟主机出来，内存512就够了</li>
  <li>下载CoreOS的ISO文件。（注意：国内对于CoreOS的下载服务器做了屏蔽，也不知道是为什么）</li>
  <li>设置CoreOS的ISO的文件作为虚拟光驱，然后启动CoreOS的虚拟机</li>
  <li>CoreOS的安装程序没有图形界面，光驱载入后只是给了个命令行的console</li>
  <li>在命令行中输入<code>sudo coreos-install -d /dev/sda</code>，然后这个脚本将下载CoreOS的安装包并开始安装 (注意：同样国内服务器屏蔽了下载服务器)</li>
  <li>安装成功后关闭CoreOS的虚拟机，<code>sudo systemctrl poweroff</code></li>
  <li>然后调整CoreOS的虚拟机，将启动顺序改为硬盘为先</li>
  <li>启动CoreOS的虚拟机，但是需要先进入GUN GRUB设置启动脚本，因为默认情况CoreOS是用证书连接的。没有用户名和密码。所以直接启动是无法登录系统的。</li>
  <li>启动CoreOS的虚拟机后用上下键选择启动default项，在最后一行的末尾加上<code>console=tty0 console=ttyS0 coreos.autologin=tty1 coreos.autologin=ttyS0</code>，然后F10保存后启动，这个时候将不需要密码进入系统了(这个改动只会一次有效，以后需要还要重新更改)</li>
  <li>注意：有可能不同的虚拟机启动的时候的cosole不是tty0或者ttyS0,则可以试一下tty1</li>
  <li>CoreOS默认安装后有用户core，这个时候可以用<code>sudo passwd core</code>来修改密码</li>
  <li>修改密码成功后，以后登录就可以用core用户和新设置的密码了</li>
  <li>CoreOS的虚拟机启动后默认已经启动了Docker，可以用<code>docker info</code>来查看docker的状态</li>
  <li>单机版的CoreOS只是拿来练习docker用的，或者是做开发环境，不可用作生产环境</li>
  <li>在Virutalbox上的虚拟主机上的网络配置端口映射（如SSH的22端口映射到主机的2222端口，这样就可以通过连接本机的2222端口到虚拟机了）</li>
</ul>

<h3 id="vagrantcoreos">Vagrant安装单一虚拟机的CoreoS集群</h3>
<hr />

<ul>
  <li>主要参照官网的文档说明<a href="https://coreos.com/docs/running-coreos/platforms/vagrant/">Running CoreOS on Vagrant</a></li>
  <li><a href="https://coreos.com/docs/running-coreos/platforms/vagrant/">Vagrant</a>主要是作为开发环境配置管理工具，需要1.6.3及以上版本</li>
  <li>根据Virtualbox以及Vagrant的说明安装好这些工具</li>
  <li>用Git克隆对应的vagrant安装CoreOS的工程</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="sh"><span class="line">git clone https://github.com/coreos/coreos-vagrant.git
</span><span class="line"><span class="nb">cd </span>coreos-vagrant
</span></code></pre></td></tr></table></div></figure></notextile></div>
<ul>
  <li>从这个项目中的example文件copy得到一份<code>user-data</code>和<code>config.rb</code>。<code>user-data</code>是CoreOS的云配置文件，是<a href="https://github.com/coreos/fleet">fleet</a>需要用到的配置内容。<code>config.rb</code>是Vagrant用到的配置选项。</li>
  <li>
    <p>修改<code>user-data</code>文件，配置<a href="https://github.com/coreos/fleet">etcd</a>用到的这个CoreOS cluster服务发现所要的etcd的服务。是不是有些绕？etcd需要ectd?后面再写个如何建etcd群的文章给CoreOS cluster用。</p>

    <ul>
      <li>使用免费的公开的etcd的服务获得一个群的token: 调用<code>https://discovery.etcd.io/new</code>得到一个token值</li>
      <li>将这个token替换discovery配置项中的<token>就可。</token></li>
      <li>需要注意的是，每次<code>vagrant destroy</code>后要重新更新这个token值</li>
      <li>每次更新这个文件后，需要用<code>vagrant reload --provision</code>的来更新VM</li>
    </ul>
  </li>
  <li>
    <p>修改<code>config.rb</code>配置文件</p>

    <ul>
      <li>设置群中服务器个的个数 <code>$num_instances=3</code></li>
      <li>设置VM的版本，如使用最新的稳定版 <code>$update_channel='stable'</code>。如果需要指定版本，则可以修改<code>Vagrantfile</code>中的config.vm.box_version配置</li>
    </ul>
  </li>
  <li>
    <p>用启动CoreOS cluster</p>

    <ul>
      <li><code>vagrant up</code> 启动，如果之前没有box，则会自动下载对应的box。注意如果有代理，则需要在环境变量中设置http_proxy以及https_proxy(windows下也要) </li>
      <li>如果只想启动一台server则可以：<code>vagrant up &lt;name&gt;</code>，默认<name>可以是core-01, core-02, core-03&#8230;</name></li>
      <li>检查启动状态：<code>vagrant status</code></li>
      <li>连接进server: <code>vagrant ssh &lt;name&gt;</code>，这样将通过证书来认证默认用户core。如果使用Putty这样的ssh client则可以参考<a href="https://github.com/Varying-Vagrant-Vagrants/VVV/wiki/Connect-to-Your-Vagrant-Virtual-Machine-with-PuTTY">用ssh登录vagrant创建的vm</a></li>
      <li>如果想共享主机目录到CoreOS则可以去掉<code>Vagrantfile</code>中关于<code>config.vm.synced_folder</code>的注释符</li>
    </ul>
  </li>
  <li>
    <p>验证CoreOS是否成功建立集群</p>

    <ul>
      <li>登录其中一台CoreOS</li>
      <li>使用命令：<code>fleetctl list-machines</code>看是否成功列出集群中所有的CoreOS服务器，如果有错误，一般是配置<code>user-data</code>文件的discovery不正确</li>
    </ul>
  </li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/03/03/scala-script/">Scala作为脚本语言动态执行</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-03-03T17:05:37+08:00" pubdate data-updated="true">Mar 3<span>rd</span>, 2015</time>
        
        
           | <a href="/blog/2015/03/03/scala-script/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3 id="section">原由</h3>
<hr />
<p>通常我们设计程序的时候都会分为3个层面，MVC是最通用的分层方式。一个是展示层，一个逻辑处理层，一个存储层。但是对于逻辑处理层还可以抽象分为两个层次，一个固定逻辑层，一个动态逻辑层。
对于动态逻辑层的实现，在Java中一般可以使用JavaScript引擎来执行JavaScript脚本。在Scala的程序中也可以这样做。不过Scala增加了使用Scala语言本身作为scritp语言。即Scala代替Javascript。
在2.11的REPL中可以这样做了，参见<a href="/blog/2015/03/02/scala211-overview/">Scala2.11Overview</a>
那么在代码中如何做呢？找了半天都没有找到官方的例子，尝试的过程中不是发现Null Point Exception的此错误就是说xxx Not Found (xxx是指Scala的类型，如Object, Int等)
在Junjun的提醒下，可能是ClassLoader的问题，造成script的执行找不到对应的jar包（包括Scala的标准包），因为默认情况下，ScriptEngine是在bootstrap路径下找jar包。参见<a href="http://docs.oracle.com/javase/7/docs/technotes/tools/findingclasses.html">Java如何找CLASS文件</a></p>

<h3 id="section-1">解决办法</h3>
<hr />

<ul>
  <li>先来看看原来在REPL中调用ScalaScript(尽管Script的代码依然是Scala，为了好区分这些是动态执行的Scala,暂且叫他ScalaScript)</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">import javax.script.ScriptEngineManager
</span><span class="line">val e = new ScriptEngineManager().getEngineByName("scala")
</span><span class="line">e.put("n", 10)
</span><span class="line">e.eval("1 to n.asInstanceOf[Int] foreach println")</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>
    <p>这些代码如果直接搬到Scala程序中，然后通过<code>java -jar</code>的方式运行是回出现我前面提到的错误的</p>
  </li>
  <li>
    <p>解决方式1： 使用<code>-xXbootclasspath</code>来指定scalascript中用到的jar包，包含scala的标准包，因为bootstrao只包含了JAVA的rt.jar以及jre/lib下面的jar包。</p>
  </li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">java -Xbootclasspath/a:/usr/scala-2.11.4/lib/scala-library.jar:/usr/scala-2.11.4/lib/scala-compiler.jar:/usr/scala-2.11.4/lib/scala-reflect.jar -jar  &lt;your jar file&gt;
</span><span class="line">//注意/a:/是固定的格式，具体可以查Jdk的文档</span></code></pre></td></tr></table></div></figure></notextile></div>
<pre><code>- 但是这个方式在前面的&lt;&lt;Java如何找CLASS文件&gt;&gt;的文中不建议，同时使用起来也比较麻烦
</code></pre>

<ul>
  <li>解决方式2： 在代码中指定scalascript和调用程度本身使用相同的jar包，代码如下：</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class=""><span class="line">import javax.script.ScriptEngineManager
</span><span class="line">import javax.script.ScriptEngine
</span><span class="line">
</span><span class="line">val m = new ScriptEngineManager()
</span><span class="line">val engine = m.getEngineByName("scala")
</span><span class="line">
</span><span class="line">//需要设计的属性
</span><span class="line">val settings = engine.asInstanceOf[scala.tools.nsc.interpreter.IMain].settings
</span><span class="line">settings.usejavacp.value = true  //使用程序的class path作为engine的class path
</span><span class="line">
</span><span class="line">engine.put("m", 10)
</span><span class="line">engine.eval("1 to m.asInstanceOf[Int] foreach println")</span></code></pre></td></tr></table></div></figure></notextile></div>
<pre><code>- 在sbt的工程中，将scala的标准包都变成依赖包，显示指定
- 然后通过`sbt assembly`来打包程序为胖程序（即包含所有的依赖包），`sbt package`不会包含依赖包的
- 直接通过`jar -jar &lt;your jar file&gt;`就可以了.
</code></pre>

<h4 id="section-2">官方讨论</h4>

<p><a href="https://github.com/scala/scala/pull/2238">Scala Issue 2238</a></p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/03/02/scala211-overview/">Scala211特性简介</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-03-02T12:02:16+08:00" pubdate data-updated="true">Mar 2<span>nd</span>, 2015</time>
        
        
           | <a href="/blog/2015/03/02/scala211-overview/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3 id="section">原由</h3>
<hr />
<p>Scala语言本生的变更还是比较快的，现在最通用是2.10和2.11版本
那么是否需要用2.11版本呢？
我们来看一看2.11的一些特性。参考于<a href="http://docs.scala-lang.org/scala/2.11/">scala2.11overview</a></p>

<h3 id="scala-211">Scala 2.11特性简介</h3>
<hr />

<ul>
  <li>
    <p>更小</p>

    <ul>
      <li>Actor包被废弃，如果的需要直接用Akka的包，已经被包含在了Scala的版准语言包了</li>
      <li>XML包被移除出scala-library.jar，编程了一个独立的包，如需要可以加入如下依赖 <code>libraryDependencies += "org.scala-lang.modules" %% "scala-xml" % "1.0.3"</code></li>
    </ul>
  </li>
  <li>更快: 提高了性能</li>
  <li>
    <p>更强</p>

    <ul>
      <li>语言：支持case class的参数多于22个参数(参见：<a href="https://issues.scala-lang.org/browse/SI-7296">1</a>)</li>
      <li>语言：增强类型推断。(不过好像这个问题又被打开了, 参见<a href="https://issues.scala-lang.org/browse/SI-1786">2</a>)</li>
      <li>REPL: 这个增强了很多项， 不一一举例了，下面是一些我个人觉得有用的。</li>
    </ul>
  </li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">scala&gt; :settings &lt;+/-&gt; &lt;flag&gt;
</span><span class="line">//这个主要是针对在REPL中提示有warning的时候，需要使用某些启动参数。原来的方式是需要退出REPL然后再用指定参数启动。现在可以直接通过这个名利来激活(+)/去除(-)某个特性(flag)，如显示deprecation，则用":settings + deprecation"</span></code></pre></td></tr></table></div></figure></notextile></div>

<pre><code>- REPL: 支持script引擎 (我个人没有用过scala下的script引擎，不知道。后面再写个如何在[代码中动态执行Scala](/blog/2015/03/03/scala-script/))
</code></pre>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/02/26/ssh-proxy-in-linux/">Ssh在linux下使用http/https代理</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-02-26T18:00:30+08:00" pubdate data-updated="true">Feb 26<span>th</span>, 2015</time>
        
        
           | <a href="/blog/2015/02/26/ssh-proxy-in-linux/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3 id="section">原由</h3>
<hr />
<p>在公司有代理的环境下，如果在linux下使用github，则可以使用https的方式。
但是https的方式需要每次都输入用户名和密码（用户名可以写在url上避免输入，但是密码就必须要）
但是如果能使用ssh的rsa方式则可以避免这个麻烦，但是ssh默认是不支持使用http/https代理的。
那么有没有办法通过某种手段让ssh支持代理呢？答案是可定的，这个工具是<a href="http://www.agroman.net/corkscrew/">Corkscrew官网</a></p>

<h3 id="section-1">解决办法</h3>
<hr />

<p>通过Corkscrew来建立隧道的方式来为ssh提供代理，具体方法如下 </p>

<ul>
  <li>安装Corkscrew（主要下载源代码，然后配置、编译、安装，典型的C程序的方式）</li>
  <li>配置ssh，在~/.ssh/目录下生成一个config=文将，然后增加一行：<code>ProxyCommand /usr/local/bin/corkscrew &lt;proxy http url&gt; &lt;proxy port&gt; %h %p</code></li>
  <li>如果是新建的config文件，注意要更改一下它的权限为600，<code>chmod 600 ~/.ssh/config</code></li>
  <li>根据github的说明配置ssh的public和private key,参考<a href="https://help.github.com/articles/generating-ssh-keys/#platform-linux">git帮助</a></li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/02/25/sublime-startup/">Sublime入门以及搭建scala开发环境</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-02-25T14:49:46+08:00" pubdate data-updated="true">Feb 25<span>th</span>, 2015</time>
        
        
           | <a href="/blog/2015/02/25/sublime-startup/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3 id="section">原由</h3>
<hr />
<p>Sublime号称是神级编辑器，同时支持多种插件的扩展。并且支持多个平台。
这里主要讲以下如何安装和配置，并说明一下如何使用scala插件来搭建开发环境，
避免使用其他的IDE这么重的工具，节约内存和系统消耗</p>

<h3 id="sublime">sublime使用入门</h3>
<hr />

<ul>
  <li>
    <p>安装sublime
可以直接从<a href="http://www.sublimetext.com/">sublime官网</a>下载对应的版本安装
这里针对不同的系统的配置的文件的路径如下：</p>

    <ul>
      <li>Mac OSX: <code>~/Library/Library/Application Support/Sublime Text 3</code></li>
      <li>Linux CentOS7: <code>~/.config/sublime-text-3</code></li>
    </ul>
  </li>
</ul>

<p>Mac OSX有对应的dmg安装包，一部一部安装就可以
CentOS7没有安装包，需要下载压缩包，4然后解压到<code>/opt/sublime-text</code>目录(注意要把名字中的3去掉)，然后将目录中的sublime_text.desktop复制到<code>/usr/share/applications</code>，这样在CentOS的启动菜单上就对应的图表了</p>

<ul>
  <li>
    <p>安装包管理插件Package Control</p>

    <ul>
      <li>最先要安装的是插件<a href="https://packagecontrol.io/installation">管理工具Package Control</a>: 下载插件包，然后放到配置路径的Installed Packages目录下就可以了。</li>
      <li>每次通过<code>shift+Ctrl+P</code>来打开命令板选择“Package Control: Install Package”来安装插件</li>
    </ul>
  </li>
  <li>
    <p>安装scala插件SublimeREPL</p>

    <ul>
      <li><code>shift+Ctrl+P</code>来打开命令板选择“Package Control: Install Package”，然后选择SublimeREPL</li>
      <li>安装成功后就可以在命令板中选择对应的scala/sbt来打开scala REPL和sbt REPL了</li>
      <li>配置： 有可能你安装sbt/scala的目录不同，造成无法打开scala REPL和sbt REPL，这个时候需要手工配置一下。在配置的文件的路径下找到<code>Packages/SublimeREPL/config/Scala</code>目录下的Main.sublime-menu文件，编辑该文件，为对应的scala和sbt指定好对应的目录就可以了</li>
      <li>使用：对于SublimeREPL:scala只是打开了scala REPL，用处不大，可以使用下面的scala worksheet插件代替。但是对于SublimeREPL:sbt则比较有用。方式是通过sublime先打开sbt的工程的目录，然后在命令板执行SublimeREPL:SBT for opened folder。不过还有更方便的插件SbblimeSBT</li>
    </ul>
  </li>
  <li>
    <p>安装scala worksheet插件</p>

    <ul>
      <li><code>shift+Ctrl+P</code>来打开命令板选择“Package Control: Install Package”，然后选择Scala Worksheet</li>
      <li>安装成功后就可以在命令板中选择对应的show scala worksheet了。</li>
      <li>使用方式是编写对应的scala文件并保存后，再执行show scala worksheet，这样scala REPL就自动会执行你编辑的文件了。</li>
      <li>有可能在打开show scala worksheet出现无法找到scala的无法，简单的解决方式是在1<code>/usr/bin</code>下给scala建立一个soft link <code>sudo ln &lt;scala install path&gt; /usr/bin/scala</code></li>
      <li>如果需要给Scala worksheet增加额外的jar包，则需要配置Sublime中的setting。<code>preferences-&gt;Settings - User</code>，然后增加一个JSON key: (注意不要用相对路径，要用绝对路径)</li>
    </ul>
  </li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">"scala_worksheet_classpath":
</span><span class="line">[
</span><span class="line">	"&lt;jar path&gt;/&lt;jar name&gt;"
</span><span class="line">]</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>
    <p>安装SublimeSBT插件</p>

    <ul>
      <li><code>shift+Ctrl+P</code>来打开命令板选择“Package Control: Install Package”，然后选择SublimeSBT</li>
      <li>使用：shift+Ctrl+P`来打开命令板选择SBT: xxx来运行对应的sbt命令</li>
    </ul>
  </li>
  <li>
    <p>给对应的scala sbt项目配置SBT插件：sbt-sublime </p>

    <ul>
      <li>在project/plugin.sbt中增加<code>addSbtPlugin("com.orrsella" % "sbt-sublime" % "1.0.9")</code></li>
      <li>在sbt console中调用<code>gen-sublime</code>来获取依赖包的源文件以及生成sublime的工程文件（每次SBT Clean都会自动删除这些文件。）。这样也节约了需要在每一个依赖包的定义后面增加withSource的选项</li>
      <li>使用步骤1： 在sublime中， project-&gt;open project来打开生成sublime的工程文件，这个时候将会将SBT的工程目录加载进来，同时多了一个External Libraries的目录（其存放了依赖包的源代码）</li>
      <li>使用步骤2： 使用SublimeSBT插件调用SBT: Start continus compiling，这样每次更改源文件都会被自动编译。如果发现错误，则Sublime会自动提示在那一行代码上</li>
      <li>使用步骤3： 因为引入了依赖包的源代码，则可以通过在sublime中的Goto菜单来调转到指定的类/方法的源文件处(仅Sublime Text 3支持)</li>
      <li>使用步骤4： 使用Snippet：case class…等来协助快速编写代码（但是不知道是上面哪个插件体提供的了）</li>
    </ul>
  </li>
  <li>
    <p>使用Git插件，在“Package Control: Install Package”中选择Git就可以了，然后在命令板选择对应的Git:xxx命令就可如Git status。</p>
  </li>
</ul>

<p>Sublime搭建Scala开发环境小结：
    - 总体而言还是不错，运行速度又快，基本的功能都有
    - 但是唯一的遗憾是没有办法在编写代码的时候自动提示可能的方法/类等</p>

<h4 id="section-1">小提示</h4>
<p>对于sublime text 3的最新版本在linus下无法使用ibus的输入法，所以编写这个blog的时候我又回到了gedit
从这个对比来看，linus和mac osx从个人用户的使用来看还是差很远的</p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/02/23/mac-port-guide/">Mac下port工具的使用</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-02-23T22:29:35+08:00" pubdate data-updated="true">Feb 23<span>rd</span>, 2015</time>
        
        
           | <a href="/blog/2015/02/23/mac-port-guide/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3 id="section">原由</h3>
<hr />

<p>Mac下面除了用dmg、pkg来安装软件外，比较方便的还有用MacPorts来帮助你安装其他应用程序，跟BSD中的ports道理一样。MacPorts就像apt-get、yum一样，可以快速安装些软件。</p>

<p>Mac下还有brew可以用来管理软件包，但是个人不喜欢这个工具，还是比较倾向于用port</p>

<h3 id="section-1">工具使用详解</h3>
<hr />

<ul>
  <li>更新ports tree(即软件信息列表)和MacPorts版本，强烈推荐第一次运行的时候使用-v参数，显示详细的更新过程。</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sudo port -v selfupdate</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>搜索索引中的软件</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">port search &lt;name&gt;</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>安装新软件</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sudo port install &lt;name&gt;</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>卸载软件</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sudo port uninstall &lt;name&gt;</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>递归卸载要卸载的软件所依赖的软件包，但这一命令不会卸载那些又依赖其他软件包的软件。</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sudo port uninstall --follow-dependencies software_name </span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>查看有更新的软件以及版本</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">port outdated</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>升级可以更新的软件</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sudo port upgrade outdated </span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>升级软件并且同时升级所依赖的软件包</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sudo port upgrade &lt;name&gt; </span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>关闭软件</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sudo port deactivate &lt;name&gt;</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>查询所需软件信息</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sudo port info &lt;name&gt; </span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>查看软件依赖性：</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sudo port deps &lt;name&gt;  </span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>清理安装过程中的缓存文件，在获取软件失败时也可以使用：</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sudo port clean --all &lt;name&gt;  </span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>查看已经安装的软件的内容信息</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">port contents &lt;name&gt;  </span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>查看已安装软件的信息</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sudo port installed &lt;name&gt;  </span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>报告所查询软件的依赖包情况</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">port dependents &lt;name&gt;  </span></code></pre></td></tr></table></div></figure></notextile></div>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/02/23/integrate-sbt-project-jenkins/">集成SBT到Jenkins中</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2015-02-23T14:56:24+08:00" pubdate data-updated="true">Feb 23<span>rd</span>, 2015</time>
        
        
           | <a href="/blog/2015/02/23/integrate-sbt-project-jenkins/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3 id="section">原由</h3>
<hr />

<p>之前有些过关于Jenkins上搭建maven工程<a href="/blog/2014/02/06/yong-jenkinsda-jian-ji-yu-githubhe-junitde-zi-dong-hua-ce-shi/">1</a>，但是对于Scala的工程最好还是用SBT，那么如何在Jenkins用SBT呢？</p>

<h3 id="section-1">解决办法</h3>
<hr />

<p>Jenkins已经提供了SBT的插件，类似Maven的插件</p>

<p>具体步骤如下：</p>

<ul>
  <li>在Jenkins上的系统管理-&gt;管理Jenkins-&gt;管理插件中选择可选插件，然后输入sbt过滤条件</li>
  <li>选择安装sbt plugin</li>
  <li>重启Jenkins</li>
  <li>配置sbt：系统管理-&gt;系统设置，设置”sbt lauch jars”，注意这里是指具体的jar文件，不是配置路径。如<code>/opt/local/share/sbt/sbt-launch.jar</code>  </li>
  <li>新建项目（因为不像Maven有特定的选项），所以选择”构建一个自由风格的软件项目”  </li>
  <li>然后在构建步骤中选择”Build using SBT”，然后配置对应的参数。这里需要注意的是JVM Flags，如果不配置很可能PerGem不够造成OutofMemoryError。但是该配置什么呢？如果不是太清楚，则可以直接拷贝sbt的启动脚本中的JVM Flags参数，如我机器的：<code>-XX:+CMSClassUnloadingEnabled -Xms1536m -Xmx1536m -XX:MaxPermSize=384m -XX:ReservedCodeCacheSize=192m -Dfile.encoding=UTF8</code></li>
  <li>如果Git repo下是涵盖了多个项目，则可以制定sub-directory path来运行特定个项目</li>
</ul>

<h3 id="section-2">小插曲</h3>

<h4 id="linuxunix">Linux/Unix下跟踪或查看文件的命令</h4>

<ol>
  <li>输入文件到console: <code>cat &lt;filename&gt;</code></li>
  <li>逐行显示文件: <code>less &lt;filename&gt;</code></li>
  <li>显示文件最后的一屏: <code>tail &lt;filename&gt;</code></li>
  <li>如果需要跟踪文件的变化则: <code>tail -f &lt;filename&gt;</code></li>
</ol>

<h4 id="git">Git清理工作空间</h4>

<p>如果在某个Repo中，你不小心加入了很多没用的文件和文件目录（或者是因为没有checkout到真确的branch就做了pull操作），则你期望一次性清理掉这些文件，可以用以下命令
不过需要注意的是这个操作不可逆的，可以通过增加<code>-n</code>参数来预览一下将会有什么变化</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="sh"><span class="line">git clean -fdx
</span></code></pre></td></tr></table></div></figure></notextile></div>

</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/3/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/08/14/docker-public-port/">如何获取docker动态分配的port</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/10/centos-ntfs-disk/">CentOS下使用NTFS格式的U盘或移动硬盘</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/07/25/fleet-ha-service-trap/">Fleet部署高可用性服务的坑</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/07/18/user-docker-mac/">在Mac下使用docker</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/07/13/zookeeper-cloud-deploy/">Zookeeper云部署方案设计</a>
      </li>
    
  </ul>
</section>




<section>
  <h1>Categories</h1>
  <ul id="categories">
    <li class='category'><a href='/blog/categories/appscale/'>Appscale (3)</a></li>
<li class='category'><a href='/blog/categories/auto-test/'>Auto Test (1)</a></li>
<li class='category'><a href='/blog/categories/bing/'>Bing (1)</a></li>
<li class='category'><a href='/blog/categories/block-storage/'>Block Storage (1)</a></li>
<li class='category'><a href='/blog/categories/centos/'>CentOS (2)</a></li>
<li class='category'><a href='/blog/categories/cloud/'>Cloud (1)</a></li>
<li class='category'><a href='/blog/categories/coreos/'>CoreOS (6)</a></li>
<li class='category'><a href='/blog/categories/data-model/'>Data Model (1)</a></li>
<li class='category'><a href='/blog/categories/design-pattern/'>Design Pattern (9)</a></li>
<li class='category'><a href='/blog/categories/docker/'>Docker (3)</a></li>
<li class='category'><a href='/blog/categories/etcd2/'>ETCD2 (1)</a></li>
<li class='category'><a href='/blog/categories/entity-model/'>Entity Model (1)</a></li>
<li class='category'><a href='/blog/categories/fp/'>FP (1)</a></li>
<li class='category'><a href='/blog/categories/findbugs/'>Findbugs (1)</a></li>
<li class='category'><a href='/blog/categories/fleet/'>Fleet (2)</a></li>
<li class='category'><a href='/blog/categories/gsl/'>GSL (1)</a></li>
<li class='category'><a href='/blog/categories/guava/'>Guava (1)</a></li>
<li class='category'><a href='/blog/categories/guice/'>Guice (2)</a></li>
<li class='category'><a href='/blog/categories/integration/'>Integration (1)</a></li>
<li class='category'><a href='/blog/categories/junit/'>JUnit (1)</a></li>
<li class='category'><a href='/blog/categories/java/'>Java (13)</a></li>
<li class='category'><a href='/blog/categories/jekyll/'>Jekyll (1)</a></li>
<li class='category'><a href='/blog/categories/jenkins/'>Jenkins (3)</a></li>
<li class='category'><a href='/blog/categories/keepalived/'>Keepalived (2)</a></li>
<li class='category'><a href='/blog/categories/linux/'>Linux (1)</a></li>
<li class='category'><a href='/blog/categories/mac/'>MAC (3)</a></li>
<li class='category'><a href='/blog/categories/maven/'>Maven (3)</a></li>
<li class='category'><a href='/blog/categories/miscellany/'>Miscellany (1)</a></li>
<li class='category'><a href='/blog/categories/oo/'>OO (1)</a></li>
<li class='category'><a href='/blog/categories/osx/'>OSX (4)</a></li>
<li class='category'><a href='/blog/categories/octopress/'>Octopress (16)</a></li>
<li class='category'><a href='/blog/categories/openstack/'>Openstack (2)</a></li>
<li class='category'><a href='/blog/categories/plantuml/'>PlantUML (3)</a></li>
<li class='category'><a href='/blog/categories/port/'>Port (2)</a></li>
<li class='category'><a href='/blog/categories/proxy/'>Proxy (2)</a></li>
<li class='category'><a href='/blog/categories/rest/'>REST (3)</a></li>
<li class='category'><a href='/blog/categories/sbt/'>SBT (2)</a></li>
<li class='category'><a href='/blog/categories/scala/'>Scala (7)</a></li>
<li class='category'><a href='/blog/categories/script/'>Script (1)</a></li>
<li class='category'><a href='/blog/categories/sublime/'>Sublime (1)</a></li>
<li class='category'><a href='/blog/categories/systemd/'>Systemd (1)</a></li>
<li class='category'><a href='/blog/categories/uml/'>UML (1)</a></li>
<li class='category'><a href='/blog/categories/virtualbox/'>VirtualBox (1)</a></li>
<li class='category'><a href='/blog/categories/zsh/'>ZSH (1)</a></li>
<li class='category'><a href='/blog/categories/zookeeper/'>Zookeeper (1)</a></li>

  </ul>
</section>
<section>
     <h1>About Me</h1>
     <iframe width="100%" height="550" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=2&ptype=1&speed=300&skin=1&isTitle=0&noborder=0&isWeibo=1&isFans=0&uid=1872168377&verifier=1cd3a528&dpc=1"></iframe>
</section>

  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - Duff Qiu -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  












</body>
</html>
